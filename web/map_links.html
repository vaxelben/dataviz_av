<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flux pays (channel_country → trending_country)</title>
  <style>
    :root { --bg:#0f172a; --panel:#0b1220; --text:#e5e7eb; --muted:#9ca3af; --border:#1f2937; }
    *{box-sizing:border-box}
    html, body { height:100%; }
    body{margin:0;background:var(--bg);color:var(--text);font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; overflow:hidden}
    header{display:none}
    main{padding:0; height:100%;}
    .row{display:grid; grid-template-columns: 1fr 360px; gap:0; height:100%;}
    #mapPanel{ padding:0; display:flex; flex-direction:column; min-height:0; }
    #filterPanel{ background:transparent; border:none; border-radius:0; padding:12px; }
    .panel{ background:transparent; border:none; border-radius:0; }
    #map{ width:100%; height:auto; min-height:0; position: relative; flex:1 1 0; }
    #chart{ width:100%; border-top:1px solid var(--border); flex:0 0 50vh; min-height:50vh; }
    #map svg{ cursor: default; }
    .btn-reset{ position:absolute; top:12px; left:12px; width:36px; height:36px; display:grid; place-items:center; border:1px solid var(--border); background:#0b1220aa; color:var(--text); border-radius:8px; cursor:pointer; z-index:5; }
    .btn-reset:hover{ background:#111827; }
    .btn-drag{ position:absolute; top:12px; left:56px; width:36px; height:36px; display:grid; place-items:center; border:1px solid var(--border); background:#0b1220aa; color:var(--text); border-radius:8px; cursor:pointer; z-index:5; }
    .btn-drag:hover{ background:#111827; }
    .btn-drag.is-on{ outline:2px solid #22c55e; }
    .btn-proj{ position:absolute; top:12px; left:100px; min-width:78px; height:36px; display:grid; place-items:center; padding:0 10px; border:1px solid var(--border); background:#0b1220aa; color:var(--text); border-radius:8px; cursor:pointer; z-index:5; }
    .btn-proj:hover{ background:#111827; }
    label{display:block;margin-bottom:8px;color:var(--muted);font-size:13px}
    select,input{width:100%;padding:8px 10px;background:#0f172a;border:1px solid var(--border);border-radius:8px;color:var(--text)}
    .tooltip{position:fixed;pointer-events:none;background:#111827;border:1px solid var(--border);padding:8px 10px;border-radius:8px;font-size:12px;color:var(--text);display:none}
    .country{ transition: fill .18s ease, stroke .18s ease, stroke-width .18s ease; }
    .country.hl{ fill:#162033; stroke:#22c55e; stroke-width:1.0; }
    .country.sel{ fill:#22c55ea5; }
    .country.dst{ fill:#22c55e30; }
  </style>
</head>
<body>
  <header>
    <div>Flux entre pays: channel_country → video_trending_country</div>
    <a href="/">Retour</a>
  </header>
  <main>
    <div class="row">
      <div class="panel" id="mapPanel">
        <div id="map">
          <button id="resetView" class="btn-reset" title="Réinitialiser la vue" aria-label="Réinitialiser la vue">⟲</button>
          <button id="toggleDrag" class="btn-drag" title="Activer/Désactiver le déplacement" aria-label="Activer/Désactiver le déplacement">✥</button>
          <button id="toggleProjection" class="btn-proj" title="Basculer projection" aria-label="Basculer projection"></button>
        </div>
        <div id="chart"></div>
      </div>
      <div class="panel" id="filterPanel" style="display:flex;flex-direction:column;gap:12px;overflow:auto">
        <div style="display:flex;align-items:center;gap:8px">
          <button id="toggleMode" title="Basculer mode flux" aria-label="Basculer mode" style="min-width:64px;border:1px solid var(--border);background:#0b1220aa;color:var(--text);border-radius:8px;padding:6px 10px;cursor:pointer">ON</button>
          <div class="muted">Mode: OFF = domestique (src = dst), ON = international (src ≠ dst)</div>
        </div>
        <!-- Source unique: yt_clean -->
        <label style="margin-top:10px">Date (video_trending_date)</label>
        <input id="dateSlider" type="range" min="0" max="0" step="1" value="0" style="width:100%" />
        <div class="muted" id="dateLabel" style="margin-top:6px">—</div>
        <label style="margin-top:12px">channel_country</label>
        <select id="srcCountries" style="width:100%"></select>
        <div style="border-top:1px solid var(--border); padding-top:10px"></div>
        <div class="muted">Vidéos sélectionnées</div>
        <div id="videoList" style="font-size:12px; line-height:1.35; max-height:40vh; overflow:auto; border:1px solid var(--border); border-radius:8px; padding:8px"></div>
      </div>
    </div>
  </main>
  <div class="tooltip" id="tip"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script>
    const $ = s => document.querySelector(s);
    const tip = $('#tip');

    const width = 980, height = 540;
    const svg = d3.select('#map').append('svg').attr('viewBox', `0 0 ${width} ${height}`).style('width','100%').style('height','100%');
    const g = svg.append('g');
    let projectionMode = 'globe';
    const baseScaleGlobe = 240;
    const baseScaleMap = 165;
    let currentZoomK = 1;
    let projection = d3.geoOrthographic().scale(baseScaleGlobe).translate([width/2, height/2]).clipAngle(90);
    let path = d3.geoPath(projection);
    let blendProjectFn = null; // fonction de projection interpolée pendant le morphing
    let blendT = 0;            // progression du morphing [0..1]
    let worldGeo = null;       // géo conservée pour morphing

    function normalizeName(s){
      if(!s) return null;
      let k = String(s).trim().toLowerCase();
      k = k.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      const synonyms = {
        'united states': 'united states of america', 'usa':'united states of america', 'etats-unis':'united states of america', 'etats unis':'united states of america',
        'uk': 'united kingdom', 'great britain':'united kingdom', 'royaume-uni':'united kingdom', 'royaume uni':'united kingdom',
        'russia':'russian federation', 'russie':'russian federation',
        'south korea':'korea, republic of', "north korea":"korea, democratic people's republic of",
        'czech republic':'czechia', 'ivory coast':"cote d'ivoire", 'swaziland':'eswatini', 'cape verde':'cabo verde', 'laos':'lao pdr',
        'burma':'myanmar',
        'espagne':'spain', 'allemagne':'germany', 'italie':'italy', 'pays-bas':'netherlands', 'emirats arabes unis':'united arab emirates',
        'fra':'france', 'fr':'france'
      };
      return synonyms[k] || k;
    }

    async function loadWorld(){
      const topo = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json').then(r=>r.json());
      const geo = topojson.feature(topo, topo.objects.countries);
      return geo;
    }

    let dates = [];
    const dateSlider = document.getElementById('dateSlider');
    const dateLabel = document.getElementById('dateLabel');
    const srcSelect = document.getElementById('srcCountries');
    const videoList = document.getElementById('videoList');
    const toggleModeBtn = document.getElementById('toggleMode');
    const toggleProjectionBtn = document.getElementById('toggleProjection');
    const projIcon = document.createElement('img');
    projIcon.width = 20;
    projIcon.height = 20;
    projIcon.alt = '';
    toggleProjectionBtn.textContent = '';
    toggleProjectionBtn.appendChild(projIcon);
    let mode = 'on'; // 'off' = domestique (src=dst), 'on' = international (src!=dst)
    let lastFlows = [];
    let zoomBehavior = null;
    let dragBehavior = null;
    let selectedVideoId = null;
    let selectedVideoData = null;
    let videosCache = [];
    const chartDiv = document.getElementById('chart');

    function flowsForSelectedVideo(){
      if (!selectedVideoData) return [];
      return [{ src: selectedVideoData.src, dst: selectedVideoData.dst, count: 1, views: selectedVideoData.views }];
    }

    async function fetchFlows(){
      const qs = new URLSearchParams();
      if(dates.length){
        const idx = +dateSlider.value || 0;
        const onDate = dates[Math.max(0, Math.min(idx, dates.length-1))];
        if(onDate) qs.set('onDate', onDate);
      }
      const selected = srcSelect.value;
      if(selected){ qs.set('src', selected); }
      if(mode){ qs.set('mode', mode); }
      const res = await fetch(`/api/flow/country?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data;
    }

    async function fetchVideos(){
      const qs = new URLSearchParams();
      if(dates.length){
        const idx = +dateSlider.value || 0;
        const onDate = dates[Math.max(0, Math.min(idx, dates.length-1))];
        if(onDate) qs.set('onDate', onDate);
      }
      const selected = srcSelect.value;
      if(selected){ qs.set('src', selected); }
      const res = await fetch(`/api/videos?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data || [];
    }

    async function fetchFlowsByVideo(videoId){
      const qs = new URLSearchParams();
      if (videoId) qs.set('videoId', videoId);
      if(dates.length){
        const idx = +dateSlider.value || 0;
        const onDate = dates[Math.max(0, Math.min(idx, dates.length-1))];
        if(onDate) qs.set('onDate', onDate);
      }
      const res = await fetch(`/api/flow/video?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data || [];
    }

    async function fetchVideoViewsTimeline(videoId){
      if (!videoId) return [];
      const qs = new URLSearchParams();
      qs.set('videoId', videoId);
      const res = await fetch(`/api/video/views_timeline?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data || [];
    }

    function renderViewsChart(data){
      chartDiv.replaceChildren();
      if (!data || !data.length) return;
      const m = {t:10, r:16, b:24, l:40};
      const w = chartDiv.clientWidth || width;
      const h = chartDiv.clientHeight || 320;
      const svgC = d3.select(chartDiv).append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', `0 0 ${w} ${h}`);
      const gx = svgC.append('g').attr('transform', `translate(${m.l},${m.t})`);
      const innerW = w - m.l - m.r;
      const innerH = h - m.t - m.b;
      const parse = d3.utcParse('%Y-%m-%d');
      const pts = data.map(d => ({ d: parse(d.date), v: +d.views||0 })).filter(d => d.d);
      if (!pts.length) return;
      const x = d3.scaleUtc().domain(d3.extent(pts, d => d.d)).range([0, innerW]);
      const y = d3.scaleLinear().domain([0, d3.max(pts, d => d.v)||1]).nice().range([innerH, 0]);
      const ax = d3.axisBottom(x).ticks(5).tickSizeOuter(0).tickFormat(d3.utcFormat('%Y-%m-%d'));
      const ay = d3.axisLeft(y).ticks(4).tickSize(-innerW).tickFormat(d3.format('.2s'));
      gx.append('g').attr('transform', `translate(0,${innerH})`).call(ax).selectAll('text').attr('fill', '#9ca3af');
      gx.append('g').call(ay).call(g => g.selectAll('text').attr('fill', '#9ca3af')).call(g => g.selectAll('line').attr('stroke', '#1f2937')).call(g => g.select('.domain').attr('stroke', '#1f2937'));
      const line = d3.line().x(d => x(d.d)).y(d => y(d.v)).curve(d3.curveMonotoneX);
      gx.append('path').datum(pts).attr('fill', 'none').attr('stroke', '#22c55e').attr('stroke-width', 2).attr('d', line);
      gx.append('path').datum(pts).attr('fill', 'url(#grad)');
      // points
      gx.selectAll('circle.pt').data(pts).join('circle').attr('class','pt').attr('cx', d => x(d.d)).attr('cy', d => y(d.v)).attr('r', 2.5).attr('fill', '#22c55e');
    }

    const anchorOverrides = {
      // lon, lat ancrés au centre métropolitain
      'france': [2.2137, 46.2276],
    };

    function updateSelectedCountryHighlight(){
      const selected = (srcSelect && srcSelect.value) ? normalizeName(srcSelect.value) : null;
      const nodes = g.selectAll('path.country');
      nodes.classed('sel', false);
      if (selected) {
        nodes.filter(function(){
          const key = this.getAttribute('data-key') || '';
          return key === selected;
        }).classed('sel', true);
      }
    }

    function countryLonLat(geo, name){
      const key = normalizeName(name);
      if (key && anchorOverrides[key]) return anchorOverrides[key];
      for(const f of geo.features){
        const nm = normalizeName(f.properties && f.properties.name);
        if(nm === key){
          const c = d3.geoCentroid(f);
          return c; // [lon, lat]
        }
      }
      return null;
    }

    function isVisibleLonLat(lonlat){
      if(!lonlat) return false;
      if (projectionMode === 'map' || projectionMode === 'blend') return true;
      const rot = d3.geoRotation(projection.rotate());
      const p = rot(lonlat);
      return d3.geoDistance([0,0], p) <= Math.PI/2 - 1e-6;
    }

    function countryCentroid(geo, name){
      const ll = countryLonLat(geo, name);
      if(!ll || !isVisibleLonLat(ll)) return null;
      if (projectionMode === 'blend' && typeof blendProjectFn === 'function') return blendProjectFn(ll);
      return projection(ll);
    }

    // Rotation animée du globe pour centrer un lon/lat au milieu
    function rotateToLonLat(lonlat, duration = 1000){
      if (projectionMode !== 'globe' || !lonlat) return;
      const r0 = projection.rotate();
      const target = [-(lonlat[0]||0), -(lonlat[1]||0), 0];
      const short = (a, b) => {
        const da = ((b - a + 540) % 360) - 180; // plus court chemin angulaire
        return (t) => a + da * t;
      };
      const yaw = short((r0[0]||0), target[0]);
      const pitch = short((r0[1]||0), target[1]);
      const roll = short((r0[2]||0), 0);
      d3.transition().duration(duration).ease(d3.easeCubicInOut)
        .tween('rotate', () => (t) => {
          projection.rotate([yaw(t), pitch(t), roll(t)]);
          render(worldGeo, lastFlows);
        });
    }

    function centerOnSelectedCountry(duration = 1000){
      if (projectionMode !== 'globe') return;
      if (!worldGeo || !srcSelect) return;
      const selected = srcSelect.value;
      if (!selected) return;
      const ll = countryLonLat(worldGeo, selected);
      if (ll) rotateToLonLat(ll, duration);
    }

    function render(geo, flows){

      g.selectAll('*').remove();
      // Sphère (océan) et graticule (visible dans les deux modes)
      g.append('path')
        .datum({type:'Sphere'})
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937')
        .attr('stroke-width', .8)
        .attr('d', path);
      g.append('path')
        .datum(d3.geoGraticule10())
        .attr('fill', 'none')
        .attr('stroke', '#1f2937')
        .attr('stroke-opacity', 0.6)
        .attr('stroke-width', .5)
        .attr('d', path);
      g.selectAll('path.country').data(geo.features).join('path')
        .attr('class', 'country')
        .attr('d', path)
        .attr('data-key', d => normalizeName(d.properties && d.properties.name) || '')
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937').attr('stroke-width', .6);

      updateSelectedCountryHighlight();

      // const maxViews = d3.max(flows, d => d.views || 0) || 1;
      const maxCount = d3.max(flows, d => d.count || 0) || 1;
      const stroke = d3.scaleSqrt().domain([1, maxCount]).range([2.0, 2.0]);
      const opacity = d3.scaleSqrt().domain([1, maxCount]).range([0.5, 1.0]);

      const arcs = flows.map(d => {
        const srcLL = countryLonLat(geo, d.src);
        const dstLL = countryLonLat(geo, d.dst);
        if(!srcLL || !dstLL) return null;
        return { srcLL, dstLL, count: d.count, views: d.views, src: d.src, dst: d.dst };
      }).filter(Boolean);

      // Colorer en vert tous les pays destination présents dans les arcs
      const dstCountries = new Set(arcs.map(a => normalizeName(a.dst)).filter(Boolean));
      g.selectAll('path.country').classed('dst', function(){
        const key = this.getAttribute('data-key') || '';
        return dstCountries.has(key);
      });

      // Dessiner des courbes quadratiques simples
      const setHighlight = (key) => {
        g.selectAll('path.country').classed('hl', false);
        if (key) {
          const sel = g.select(`path.country[data-key="${key}"]`);
          sel.classed('hl', true);
        }
      };

      g.selectAll('path.flow').data(arcs).join('path')
        .attr('class', 'flow')
        .attr('fill', 'none')
        .attr('stroke', '#22c55e')
        .attr('stroke-opacity', d => opacity(d.count||0))
        .attr('stroke-width', d => stroke(d.count||0))
        .attr('d', d => {
          if (projectionMode === 'globe'){
            const interpolate = d3.geoInterpolate(d.srcLL, d.dstLL);
            const dist = d3.geoDistance(d.srcLL, d.dstLL);
            const steps = Math.max(8, Math.ceil(dist * 32));
            const coords = d3.range(steps + 1).map(t => interpolate(t/steps));
            const line = { type:'LineString', coordinates: coords };
            return path(line) || null;
          } else {
            const a = projection(d.srcLL);
            const b = projection(d.dstLL);
            const [x1,y1] = a, [x2,y2] = b;
            const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
            const dx = x2 - x1, dy = y2 - y1;
            const norm = Math.sqrt(dx*dx + dy*dy) || 1;
            const base = Math.min(80, norm * 0.3);
            const horiz = Math.abs(dx) / norm;
            const off = base * horiz;
            let px = -dy / norm, py = dx / norm; // perpendiculaire +90°
            if (py > 0) { px = -px; py = -py; } // garantir une composante y négative (vers le haut)
            const cx = mx + px * off;
            const cy = my + py * off;
            return `M${x1},${y1} Q${cx},${cy} ${x2},${y2}`;
          }
        })
        .on('mouseenter', (ev, d) => {
          const key = normalizeName(d.dst);
          setHighlight(key);
        })
        .on('mousemove', (ev, d) => {
          tip.style.display = 'block';
          tip.style.left = (ev.clientX + 12) + 'px';
          tip.style.top = (ev.clientY + 12) + 'px';
          const v = d.views || 0;
          tip.textContent = `${d.src} → ${d.dst}: ${d.count} vidéos, ${d3.format(',')(v)} vues`;
        })
        .on('mouseleave', ()=>{ tip.style.display = 'none'; setHighlight(null); });

      // Cercles pour les flux où src == dst (comptage de vidéos distinctes au jour sélectionné)
      const selfFlows = flows.filter(d => normalizeName(d.src) === normalizeName(d.dst));
      const maxSelf = d3.max(selfFlows, d => d.count || 0) || 1;
      const rSelf = d3.scaleSqrt().domain([1, maxSelf]).range([3, 16]);
      const points = selfFlows.map(d => {
        const ll = countryLonLat(geo, d.dst);
        if(!ll || !isVisibleLonLat(ll)) return null;
        const c = projection(ll);
        return { x:c[0], y:c[1], country:d.dst, count:d.count };
      }).filter(Boolean);

      g.selectAll('circle.self-flow').data(points).join('circle')
        .attr('class', 'self-flow')
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('r', d => rSelf(d.count||0))
        .attr('fill', '#22c55e')
        .attr('fill-opacity', 0.28)
        .attr('stroke', '#22c55e')
        .attr('stroke-width', 1)
        .on('mouseenter', (ev, d) => { setHighlight(normalizeName(d.country)); })
        .on('mousemove', (ev, d) => {
          tip.style.display = 'block';
          tip.style.left = (ev.clientX + 12) + 'px';
          tip.style.top = (ev.clientY + 12) + 'px';
          tip.textContent = `${d.country}: ${d.count} vidéo(s)`;
        })
        .on('mouseleave', ()=>{ tip.style.display = 'none'; setHighlight(null); });
    }

    // Rendu statique dans un calque dédié, pour crossfade (sans interactions)
    function renderSnapshot(geo, flows, mode, targetG){
      targetG.selectAll('*').remove();
      // config locale de projection
      const proj = (mode === 'globe')
        ? d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate(projection.rotate())
        : d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]);
      const pth = d3.geoPath(proj);

      const localIsVisible = (lonlat) => {
        if(!lonlat) return false;
        if (mode === 'map') return true;
        const rot = d3.geoRotation(proj.rotate());
        const pp = rot(lonlat);
        return d3.geoDistance([0,0], pp) <= Math.PI/2 - 1e-6;
      };

      const countryLL = (name) => {
        const key = normalizeName(name);
        if (key && anchorOverrides[key]) return anchorOverrides[key];
        for(const f of geo.features){
          const nm = normalizeName(f.properties && f.properties.name);
          if(nm === key){ return d3.geoCentroid(f); }
        }
        return null;
      };

      targetG.append('path')
        .datum({type:'Sphere'})
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937')
        .attr('stroke-width', .8)
        .attr('d', pth);
      targetG.append('path')
        .datum(d3.geoGraticule10())
        .attr('fill', 'none')
        .attr('stroke', '#1f2937')
        .attr('stroke-opacity', 0.6)
        .attr('stroke-width', .5)
        .attr('d', pth);
      targetG.selectAll('path.country').data(geo.features).join('path')
        .attr('class', 'country')
        .attr('d', pth)
        .attr('data-key', d => normalizeName(d.properties && d.properties.name) || '')
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937').attr('stroke-width', .6);

      const maxCount = d3.max(flows, d => d.count || 0) || 1;
      const stroke = d3.scaleSqrt().domain([1, maxCount]).range([0.5, 0.5]);
      const opacity = d3.scaleSqrt().domain([1, maxCount]).range([0.25, 0.95]);

      const arcs = flows.map(d => {
        const srcLL = countryLL(d.src);
        const dstLL = countryLL(d.dst);
        if(!srcLL || !dstLL) return null;
        return { srcLL, dstLL, count: d.count, views: d.views, src: d.src, dst: d.dst };
      }).filter(Boolean);

      targetG.selectAll('path.flow').data(arcs).join('path')
        .attr('class', 'flow')
        .attr('fill', 'none')
        .attr('stroke', '#22c55e')
        .attr('stroke-opacity', d => opacity(d.count||0))
        .attr('stroke-width', d => stroke(d.count||0))
        .attr('d', d => {
          if (mode === 'globe'){
            const interpolate = d3.geoInterpolate(d.srcLL, d.dstLL);
            const dist = d3.geoDistance(d.srcLL, d.dstLL);
            const steps = Math.max(8, Math.ceil(dist * 32));
            const coords = d3.range(steps + 1).map(t => interpolate(t/steps));
            const line = { type:'LineString', coordinates: coords };
            return pth(line) || null;
          } else {
            const a = proj(d.srcLL);
            const b = proj(d.dstLL);
            const [x1,y1] = a, [x2,y2] = b;
            const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
            const dx = x2 - x1, dy = y2 - y1;
            const norm = Math.sqrt(dx*dx + dy*dy) || 1;
            const base = Math.min(80, norm * 0.3);
            const horiz = Math.abs(dx) / norm;
            const off = base * horiz;
            let px = -dy / norm, py = dx / norm;
            if (py > 0) { px = -px; py = -py; }
            const cx = mx + px * off;
            const cy = my + py * off;
            return `M${x1},${y1} Q${cx},${cy} ${x2},${y2}`;
          }
        });

      const selfFlows = flows.filter(d => normalizeName(d.src) === normalizeName(d.dst));
      const maxSelf = d3.max(selfFlows, d => d.count || 0) || 1;
      const rSelf = d3.scaleSqrt().domain([1, maxSelf]).range([3, 16]);
      const points = selfFlows.map(d => {
        const ll = countryLL(d.dst);
        if(!ll || !localIsVisible(ll)) return null;
        const c = proj(ll);
        return { x:c[0], y:c[1], country:d.dst, count:d.count };
      }).filter(Boolean);

      targetG.selectAll('circle.self-flow').data(points).join('circle')
        .attr('class', 'self-flow')
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('r', d => rSelf(d.count||0))
        .attr('fill', '#22c55e')
        .attr('fill-opacity', 0.28)
        .attr('stroke', '#22c55e')
        .attr('stroke-width', 1);
    }

    async function init(){
      const [geo, dateList] = await Promise.all([
        loadWorld(),
        fetch(`/api/meta/dates`).then(r=>r.json()).catch(()=>({dates:[]}))
      ]);
      worldGeo = geo;
      dates = (dateList && Array.isArray(dateList.dates)) ? dateList.dates : [];
      dateSlider.min = 0; dateSlider.max = Math.max(0, dates.length-1); dateSlider.value = 0;
      dateLabel.textContent = dates.length ? dates[0] : '—';
      // Charger les pays source
      const channels = await fetch('/api/meta/channels').then(r=>r.json()).catch(()=>({countries:[]}));
      const countries = (channels && Array.isArray(channels.countries)) ? channels.countries : [];
      srcSelect.replaceChildren(...countries.map(c => {
        const opt = document.createElement('option');
        opt.value = c; opt.textContent = c; return opt;
      }));
      // Sélection par défaut: France
      const franceOpt = Array.from(srcSelect.options).find(o => (o.value||'').toLowerCase() === 'france');
      if(franceOpt){ srcSelect.value = franceOpt.value; }
      const [flows, vids] = await Promise.all([
        fetchFlows(),
        fetchVideos()
      ]);
      lastFlows = flows;
      render(geo, flows);
      centerOnSelectedCountry(800);
      videosCache = vids;
      renderVideoList(videosCache);

      // Zoom & drag dépendants de la projection
      let dragEnabled = false;
      let isCtrlDown = false;
      function isDragActive(){ return !!(dragEnabled || isCtrlDown); }
      function setupInteractions(){
        // nettoyer anciens handlers
        svg.on('.zoom', null).on('.drag', null);
        if (projectionMode === 'globe'){
          // reset transform
          g.attr('transform', null);
          currentZoomK = Math.max(0.7, Math.min(12, currentZoomK));
          projection.scale(baseScaleGlobe * currentZoomK);
          zoomBehavior = d3.zoom()
            .scaleExtent([0.7, 12])
            .filter((event) => event.type === 'wheel')
            .on('zoom', (ev) => {
              currentZoomK = ev.transform.k;
              projection.scale(baseScaleGlobe * currentZoomK);
              render(geo, lastFlows);
            });
          svg.call(zoomBehavior).on('dblclick.zoom', null);

          dragBehavior = d3.drag()
            .filter((event) => isDragActive() && event.button === 0)
            .on('start', (ev) => {
              svg.style('cursor','grabbing');
              dragBehavior.__start = { x: ev.x, y: ev.y, r: projection.rotate() };
            })
            .on('drag', (ev) => {
              const s = dragBehavior.__start || { x: ev.x, y: ev.y, r: projection.rotate() };
              const dx = ev.x - s.x;
              const dy = ev.y - s.y;
              const sens = 0.25; // degrés par pixel
              const r0 = s.r || [0,0,0];
              const r = [ r0[0] + dx * sens, r0[1] - dy * sens, r0[2] || 0 ];
              projection.rotate(r);
              render(geo, lastFlows);
            })
            .on('end', () => { svg.style('cursor', isDragActive() ? 'grab' : 'default'); });
          svg.call(dragBehavior);
        } else {
          // mode carte: zoom/pan via transform, projection à l'échelle base
          projection = d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]);
          path = d3.geoPath(projection);
          zoomBehavior = d3.zoom()
            .scaleExtent([0.7, 12])
            .filter((event) => {
              if (event.type === 'wheel') return true;
              if (event.type === 'mousedown') return isDragActive() && event.button === 0;
              return false;
            })
            .on('start', () => { if (isDragActive()) svg.style('cursor','grabbing'); })
            .on('end',   () => { svg.style('cursor', isDragActive() ? 'grab' : 'default'); })
            .on('zoom', (ev) => { g.attr('transform', ev.transform); });
          svg.call(zoomBehavior).on('dblclick.zoom', null);
        }
      }

      // Bouton de réinitialisation de la vue
      const btnReset = document.getElementById('resetView');
      function resetView(){
        if (zoomBehavior) {
          svg.transition().duration(350).call(zoomBehavior.transform, d3.zoomIdentity);
        } else {
          g.attr('transform', null);
          currentZoomK = 1;
          projection = (projectionMode === 'globe')
            ? d3.geoOrthographic().scale(baseScaleGlobe).translate([width/2, height/2]).clipAngle(90)
            : d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]);
          path = d3.geoPath(projection);
          render(worldGeo, lastFlows);
        }
      }
      btnReset.addEventListener('click', resetView);

      // Bouton toggle drag
      const btnDrag = document.getElementById('toggleDrag');
      function updateDragUI(){
        btnDrag.classList.toggle('is-on', isDragActive());
        svg.style('cursor', isDragActive() ? 'grab' : 'default');
      }
      updateDragUI();
      btnDrag.addEventListener('click', () => {
        dragEnabled = !dragEnabled;
        updateDragUI();
      });

      // Activer le drag en maintenant Ctrl (sans changer l'état du bouton)
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Control' || e.ctrlKey) {
          if (!isCtrlDown) { isCtrlDown = true; updateDragUI(); }
        }
      });
      window.addEventListener('keyup', (e) => {
        if (e.key === 'Control' || (!e.ctrlKey && isCtrlDown)) {
          isCtrlDown = false; updateDragUI();
        }
      });

      function setProjectionMode(mode){
        const prevMode = projectionMode;
        const prevRotate = (typeof projection.rotate === 'function') ? projection.rotate() : [0,0,0];
        // Morphing réel des chemins entre prevMode -> mode
        morphProjection(prevMode, mode, prevRotate);
      }

      function morphProjection(prevMode, targetMode, prevRotate){
        // désactiver interactions pendant morph
        svg.on('.zoom', null).on('.drag', null);

        // Capturer le transform actuel avant de le modifier
        const currentTransform = d3.zoomTransform(svg.node());

        // Créer les projections source et cible avec gestion cohérente des échelles
        let proj0, proj1;
        
        const yawOnly = (Array.isArray(prevRotate) ? prevRotate[0] : 0) || 0;
        
        if (prevMode === 'globe') {
          // Pendant l'interpolation, neutraliser pitch/roll -> garder uniquement le yaw
          proj0 = d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate([yawOnly, 0, 0]);
        } else {
          // En mode carte, créer une projection qui reflète l'état visuel actuel (yaw uniquement)
          proj0 = d3.geoNaturalEarth1().scale(baseScaleMap * currentTransform.k).translate([
            width/2 + currentTransform.x, 
            height/2 + currentTransform.y
          ]).rotate([yawOnly, 0, 0]);
        }
          
        if (targetMode === 'globe') {
          // Pendant l'interpolation, neutraliser pitch/roll -> garder uniquement le yaw
          proj1 = d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate([yawOnly, 0, 0]);
        } else {
          proj1 = d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]).rotate([yawOnly, 0, 0]);
        }

        projectionMode = 'blend';
        const dur = 1200;

        // Supprimer le transform immédiatement pour éviter les conflits
        g.attr('transform', null);

        // Créer une transition unique et cohérente pour tous les éléments
        const transition = g.transition().duration(dur).ease(d3.easeQuadInOut);

        // Méthode standard D3 (ObservableHQ) : interpolation point par point entre projections
        const createPathTween = (geom) => {
          return (t) => {
            const interpolatedProj = d3.geoProjection((lambda, phi) => {
              const lonlat = [lambda * 180 / Math.PI, phi * -180 / Math.PI];
              const p0 = proj0(lonlat);
              const p1 = proj1(lonlat);
              if (!p0 || !p1) return null;
              return [
                p0[0] + t * (p1[0] - p0[0]), 
                p0[1] + t * (p1[1] - p0[1])
              ];
            }).scale(1).translate([width/2, height/2]);
            
            // Ne pas interpoler la rotation pour éviter un saut d'orientation
            
            return d3.geoPath(interpolatedProj)(geom);
          };
        };

        // Animer tous les pays
        transition.selectAll('path.country')
          .attrTween('d', function(d) { return createPathTween(d); });

        // Animer la sphère
        transition.selectAll('path')
          .filter((d) => d && d.type === 'Sphere')
          .attrTween('d', function(d) { return createPathTween(d); });

        // Animer le graticule
        const graticule = d3.geoGraticule10();
        transition.selectAll('path')
          .filter((d) => d && d.type === 'MultiLineString')
          .attrTween('d', function() { return createPathTween(graticule); });

        // Animer les flows (toujours en géodésiques pour la cohérence)
        transition.selectAll('path.flow')
          .attrTween('d', function(d) {
            return (t) => {
              const interpolate = d3.geoInterpolate(d.srcLL, d.dstLL);
              const dist = d3.geoDistance(d.srcLL, d.dstLL);
              const steps = Math.max(8, Math.ceil(dist * 20));
              const coords = d3.range(steps + 1).map(s => interpolate(s/steps));
              const line = { type:'LineString', coordinates: coords };
              return createPathTween(line)(t);
            };
          });

        // Animer les points self-flow
        transition.selectAll('circle.self-flow')
          .attrTween('cx', function(d){
            const ll = countryLonLat(worldGeo, d.country);
            if (!ll) return null;
            return (t) => {
              const p0 = proj0(ll);
              const p1 = proj1(ll);
              if (!p0 || !p1) return null;
              return p0[0] + t * (p1[0] - p0[0]);
            };
          })
          .attrTween('cy', function(d){
            const ll = countryLonLat(worldGeo, d.country);
            if (!ll) return null;
            return (t) => {
              const p0 = proj0(ll);
              const p1 = proj1(ll);
              if (!p0 || !p1) return null;
              return p0[1] + t * (p1[1] - p0[1]);
            };
          });

        // À la fin de la transition
        transition.on('end', () => {
          projectionMode = targetMode;
          if (targetMode === 'globe'){
            // Restaurer la rotation complète utilisateur (yaw/pitch/roll)
            projection = d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate(prevRotate);
          } else {
            projection = d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]).rotate([yawOnly, 0, 0]);
          }
          path = d3.geoPath(projection);
          setupInteractions();
          render(worldGeo, lastFlows);
          updateProjectionUI();
          updateSelectedCountryHighlight();
          if (targetMode === 'globe') { centerOnSelectedCountry(800); }
        });
      }

      function updateProjectionUI(){
        const isGlobe = (projectionMode === 'globe');
        projIcon.src = isGlobe ? '/public/img/globe_24p.svg' : '/public/img/map_24p.svg';
        projIcon.alt = isGlobe ? 'Globe' : 'Carte';
      }
      updateProjectionUI();
      toggleProjectionBtn.addEventListener('click', () => {
        const next = (projectionMode === 'globe') ? 'map' : 'globe';
        setProjectionMode(next);
      });

      // initialiser interactions selon mode courant
      setupInteractions();

      const refresh = async () => {
        const [fl, vids] = await Promise.all([
          selectedVideoId ? fetchFlowsByVideo(selectedVideoId) : fetchFlows(),
          fetchVideos()
        ]);
        lastFlows = fl;
        render(geo, fl);
        videosCache = vids;
        renderVideoList(videosCache);
        const tl = await (selectedVideoId ? fetchVideoViewsTimeline(selectedVideoId) : Promise.resolve([]));
        renderViewsChart(tl);
      };

      async function refreshMapOnly(){
        const fl = await (selectedVideoId ? fetchFlowsByVideo(selectedVideoId) : fetchFlows());
        lastFlows = fl;
        render(geo, fl);
      }

      function highlightSelectedVideoRow(){
        const rows = Array.from(videoList.children);
        rows.forEach(row => {
          const isSel = selectedVideoId && row.dataset && row.dataset.videoId === selectedVideoId;
          row.style.background = isSel ? '#0b3a2a' : '';
        });
      }

      function renderVideoList(vids){
        const fmtNum = (n) => {
          const x = +n || 0;
          if (x >= 1000000) return (x/1000000).toFixed(x % 1000000 === 0 ? 0 : 1) + 'M';
          if (x >= 1000) return (x/1000).toFixed(x % 1000 === 0 ? 0 : 1) + 'k';
          return d3.format(',')(x);
        };

        // En-tête
        const header = document.createElement('div');
        header.style.display = 'grid';
        header.style.gridTemplateColumns = '1fr auto auto';
        header.style.gap = '8px';
        header.style.position = 'sticky';
        header.style.top = '0';
        header.style.background = '#0b1220';
        header.style.borderBottom = '1px solid var(--border)';
        header.style.padding = '4px 4px 6px 4px';
        const hTitle = document.createElement('div');
        const hViews = document.createElement('div');
        const hLikes = document.createElement('div');
        const iTitle = document.createElement('img'); iTitle.src = '/public/img/youtube_24p.svg'; iTitle.width = 18; iTitle.height = 18; iTitle.alt = 'YouTube'; iTitle.style.opacity = '0.9';
        const iViews = document.createElement('img'); iViews.src = '/public/img/views_24p.svg'; iViews.width = 18; iViews.height = 18; iViews.alt = 'Vues'; iViews.style.opacity = '0.8';
        const iLikes = document.createElement('img'); iLikes.src = '/public/img/thumbs_up_24p.svg'; iLikes.width = 18; iLikes.height = 18; iLikes.alt = 'Likes'; iLikes.style.opacity = '0.8';
        hTitle.appendChild(iTitle); hViews.appendChild(iViews); hLikes.appendChild(iLikes);
        header.appendChild(hTitle); header.appendChild(hViews); header.appendChild(hLikes);

        // Lignes
        const rows = vids.map(v => {
          const row = document.createElement('div');
          row.style.display = 'grid';
          row.style.gridTemplateColumns = '1fr auto auto';
          row.style.gap = '8px';
          row.style.cursor = 'pointer';
          row.dataset.videoId = v.video_id;
          const title = document.createElement('div');
          title.textContent = v.video_title || v.video_id;
          const views = document.createElement('div');
          views.textContent = fmtNum(v.views||0);
          views.style.color = '#9ca3af';
          const likes = document.createElement('div');
          likes.textContent = fmtNum(v.likes||0);
          likes.style.color = '#9ca3af';
          row.appendChild(title); row.appendChild(views); row.appendChild(likes);
          row.addEventListener('click', async () => {
            if (selectedVideoId === v.video_id){
              selectedVideoId = null; selectedVideoData = null;
            } else {
              selectedVideoId = v.video_id; selectedVideoData = v;
            }
            highlightSelectedVideoRow();
            await refreshMapOnly();
            const timeline = await fetchVideoViewsTimeline(selectedVideoId);
            renderViewsChart(timeline);
          });
          return row;
        });
        videoList.replaceChildren(header, ...rows);
        highlightSelectedVideoRow();
      }
      // Source fixe: yt_clean (pas d'écouteur de changement de table)
      dateSlider.addEventListener('input', async ()=>{
        dateLabel.textContent = dates.length ? dates[+dateSlider.value] : '—';
        selectedVideoId = null; selectedVideoData = null;
        await refresh();
      });
      srcSelect.addEventListener('change', () => {
        selectedVideoId = null; selectedVideoData = null;
        updateSelectedCountryHighlight(); centerOnSelectedCountry(800); refresh();
      });
      toggleModeBtn.addEventListener('click', async () => {
        mode = (mode === 'off') ? 'on' : 'off';
        toggleModeBtn.textContent = mode.toUpperCase();
        selectedVideoId = null; selectedVideoData = null;
        await refresh();
      });
    }
    init();
  </script>
</body>
</html>


