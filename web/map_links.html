<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flux pays (channel_country → trending_country)</title>
  <style>
    :root { --bg:#0f172a; --panel:#0b1220; --text:#e5e7eb; --muted:#9ca3af; --border:#1f2937; }
    *{box-sizing:border-box}
    html, body { height:100%; }
    body{margin:0;background:var(--bg);color:var(--text);font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; overflow:hidden}
    header{display:none}
    main{padding:0; height:100%;}
    .row{display:grid; grid-template-columns: 1fr 360px; gap:0; height:100%;}
    #mapPanel{ padding:0; }
    #filterPanel{ background:transparent; border:none; border-radius:0; padding:12px; }
    .panel{ background:transparent; border:none; border-radius:0; }
    #map{ width:100%; height:100%; position: relative; }
    #map svg{ cursor: default; }
    .btn-reset{ position:absolute; top:12px; left:12px; width:36px; height:36px; display:grid; place-items:center; border:1px solid var(--border); background:#0b1220aa; color:var(--text); border-radius:8px; cursor:pointer; z-index:5; }
    .btn-reset:hover{ background:#111827; }
    .btn-drag{ position:absolute; top:12px; left:56px; width:36px; height:36px; display:grid; place-items:center; border:1px solid var(--border); background:#0b1220aa; color:var(--text); border-radius:8px; cursor:pointer; z-index:5; }
    .btn-drag:hover{ background:#111827; }
    .btn-drag.is-on{ outline:2px solid #22c55e; }
    .btn-proj{ position:absolute; top:12px; left:100px; min-width:78px; height:36px; display:grid; place-items:center; padding:0 10px; border:1px solid var(--border); background:#0b1220aa; color:var(--text); border-radius:8px; cursor:pointer; z-index:5; }
    .btn-proj:hover{ background:#111827; }
    label{display:block;margin-bottom:8px;color:var(--muted);font-size:13px}
    select,input{width:100%;padding:8px 10px;background:#0f172a;border:1px solid var(--border);border-radius:8px;color:var(--text)}
    .tooltip{position:fixed;pointer-events:none;background:#111827;border:1px solid var(--border);padding:8px 10px;border-radius:8px;font-size:12px;color:var(--text);display:none}
    .country{ transition: fill .18s ease, stroke .18s ease, stroke-width .18s ease; }
    .country.hl{ fill:#162033; stroke:#22c55e; stroke-width:1.0; }
  </style>
</head>
<body>
  <header>
    <div>Flux entre pays: channel_country → video_trending_country</div>
    <a href="/">Retour</a>
  </header>
  <main>
    <div class="row">
      <div class="panel" id="mapPanel">
        <div id="map">
          <button id="resetView" class="btn-reset" title="Réinitialiser la vue" aria-label="Réinitialiser la vue">⟲</button>
          <button id="toggleDrag" class="btn-drag" title="Activer/Désactiver le déplacement" aria-label="Activer/Désactiver le déplacement">✥</button>
          <button id="toggleProjection" class="btn-proj" title="Basculer projection" aria-label="Basculer projection">GLOBE</button>
        </div>
      </div>
      <div class="panel" id="filterPanel" style="display:flex;flex-direction:column;gap:12px;overflow:auto">
        <div style="display:flex;align-items:center;gap:8px">
          <button id="toggleMode" title="Basculer mode flux" aria-label="Basculer mode" style="min-width:64px;border:1px solid var(--border);background:#0b1220aa;color:var(--text);border-radius:8px;padding:6px 10px;cursor:pointer">OFF</button>
          <div class="muted">Mode: OFF = domestique (src = dst), ON = international (src ≠ dst)</div>
        </div>
        <!-- Source unique: yt_clean -->
        <label style="margin-top:10px">Date (video_trending_date)</label>
        <input id="dateSlider" type="range" min="0" max="0" step="1" value="0" style="width:100%" />
        <div class="muted" id="dateLabel" style="margin-top:6px">—</div>
        <label style="margin-top:12px">channel_country</label>
        <select id="srcCountries" style="width:100%"></select>
        <div style="border-top:1px solid var(--border); padding-top:10px"></div>
        <div class="muted">Vidéos sélectionnées</div>
        <div id="videoList" style="font-size:12px; line-height:1.35; max-height:40vh; overflow:auto; border:1px solid var(--border); border-radius:8px; padding:8px"></div>
      </div>
    </div>
  </main>
  <div class="tooltip" id="tip"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script>
    const $ = s => document.querySelector(s);
    const tip = $('#tip');

    const width = 980, height = 540;
    const svg = d3.select('#map').append('svg').attr('viewBox', `0 0 ${width} ${height}`).style('width','100%').style('height','100%');
    const g = svg.append('g');
    let projectionMode = 'globe';
    const baseScaleGlobe = 240;
    const baseScaleMap = 165;
    let currentZoomK = 1;
    let projection = d3.geoOrthographic().scale(baseScaleGlobe).translate([width/2, height/2]).clipAngle(90);
    let path = d3.geoPath(projection);
    let blendProjectFn = null; // fonction de projection interpolée pendant le morphing
    let blendT = 0;            // progression du morphing [0..1]
    let worldGeo = null;       // géo conservée pour morphing

    function normalizeName(s){
      if(!s) return null;
      let k = String(s).trim().toLowerCase();
      k = k.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      const synonyms = {
        'united states': 'united states of america', 'usa':'united states of america', 'etats-unis':'united states of america', 'etats unis':'united states of america',
        'uk': 'united kingdom', 'great britain':'united kingdom', 'royaume-uni':'united kingdom', 'royaume uni':'united kingdom',
        'russia':'russian federation', 'russie':'russian federation',
        'south korea':'korea, republic of', "north korea":"korea, democratic people's republic of",
        'czech republic':'czechia', 'ivory coast':"cote d'ivoire", 'swaziland':'eswatini', 'cape verde':'cabo verde', 'laos':'lao pdr',
        'burma':'myanmar',
        'espagne':'spain', 'allemagne':'germany', 'italie':'italy', 'pays-bas':'netherlands', 'emirats arabes unis':'united arab emirates',
        'fra':'france', 'fr':'france'
      };
      return synonyms[k] || k;
    }

    async function loadWorld(){
      const topo = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json').then(r=>r.json());
      const geo = topojson.feature(topo, topo.objects.countries);
      return geo;
    }

    let dates = [];
    const dateSlider = document.getElementById('dateSlider');
    const dateLabel = document.getElementById('dateLabel');
    const srcSelect = document.getElementById('srcCountries');
    const videoList = document.getElementById('videoList');
    const toggleModeBtn = document.getElementById('toggleMode');
    const toggleProjectionBtn = document.getElementById('toggleProjection');
    let mode = 'off'; // 'off' = domestique (src=dst), 'on' = international (src!=dst)
    let lastFlows = [];
    let zoomBehavior = null;
    let dragBehavior = null;

    async function fetchFlows(){
      const qs = new URLSearchParams();
      if(dates.length){
        const idx = +dateSlider.value || 0;
        const onDate = dates[Math.max(0, Math.min(idx, dates.length-1))];
        if(onDate) qs.set('onDate', onDate);
      }
      const selected = srcSelect.value;
      if(selected){ qs.set('src', selected); }
      if(mode){ qs.set('mode', mode); }
      const res = await fetch(`/api/flow/country?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data;
    }

    async function fetchVideos(){
      const qs = new URLSearchParams();
      if(dates.length){
        const idx = +dateSlider.value || 0;
        const onDate = dates[Math.max(0, Math.min(idx, dates.length-1))];
        if(onDate) qs.set('onDate', onDate);
      }
      const selected = srcSelect.value;
      if(selected){ qs.set('src', selected); }
      const res = await fetch(`/api/videos?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data || [];
    }

    const anchorOverrides = {
      // lon, lat ancrés au centre métropolitain
      'france': [2.2137, 46.2276],
    };

    function countryLonLat(geo, name){
      const key = normalizeName(name);
      if (key && anchorOverrides[key]) return anchorOverrides[key];
      for(const f of geo.features){
        const nm = normalizeName(f.properties && f.properties.name);
        if(nm === key){
          const c = d3.geoCentroid(f);
          return c; // [lon, lat]
        }
      }
      return null;
    }

    function isVisibleLonLat(lonlat){
      if(!lonlat) return false;
      if (projectionMode === 'map' || projectionMode === 'blend') return true;
      const rot = d3.geoRotation(projection.rotate());
      const p = rot(lonlat);
      return d3.geoDistance([0,0], p) <= Math.PI/2 - 1e-6;
    }

    function countryCentroid(geo, name){
      const ll = countryLonLat(geo, name);
      if(!ll || !isVisibleLonLat(ll)) return null;
      if (projectionMode === 'blend' && typeof blendProjectFn === 'function') return blendProjectFn(ll);
      return projection(ll);
    }

    function render(geo, flows){

      g.selectAll('*').remove();
      // Sphère (océan) et graticule (visible dans les deux modes)
      g.append('path')
        .datum({type:'Sphere'})
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937')
        .attr('stroke-width', .8)
        .attr('d', path);
      g.append('path')
        .datum(d3.geoGraticule10())
        .attr('fill', 'none')
        .attr('stroke', '#1f2937')
        .attr('stroke-opacity', 0.6)
        .attr('stroke-width', .5)
        .attr('d', path);
      g.selectAll('path.country').data(geo.features).join('path')
        .attr('class', 'country')
        .attr('d', path)
        .attr('data-key', d => normalizeName(d.properties && d.properties.name) || '')
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937').attr('stroke-width', .6);

      // const maxViews = d3.max(flows, d => d.views || 0) || 1;
      const maxCount = d3.max(flows, d => d.count || 0) || 1;
      const stroke = d3.scaleSqrt().domain([1, maxCount]).range([0.5, 0.5]);
      const opacity = d3.scaleSqrt().domain([1, maxCount]).range([0.25, 0.95]);

      const arcs = flows.map(d => {
        const srcLL = countryLonLat(geo, d.src);
        const dstLL = countryLonLat(geo, d.dst);
        if(!srcLL || !dstLL) return null;
        return { srcLL, dstLL, count: d.count, views: d.views, src: d.src, dst: d.dst };
      }).filter(Boolean);

      // Dessiner des courbes quadratiques simples
      const setHighlight = (key) => {
        g.selectAll('path.country').classed('hl', false);
        if (key) {
          const sel = g.select(`path.country[data-key="${key}"]`);
          sel.classed('hl', true);
        }
      };

      g.selectAll('path.flow').data(arcs).join('path')
        .attr('class', 'flow')
        .attr('fill', 'none')
        .attr('stroke', '#22c55e')
        .attr('stroke-opacity', d => opacity(d.count||0))
        .attr('stroke-width', d => stroke(d.count||0))
        .attr('d', d => {
          if (projectionMode === 'globe'){
            const interpolate = d3.geoInterpolate(d.srcLL, d.dstLL);
            const dist = d3.geoDistance(d.srcLL, d.dstLL);
            const steps = Math.max(8, Math.ceil(dist * 32));
            const coords = d3.range(steps + 1).map(t => interpolate(t/steps));
            const line = { type:'LineString', coordinates: coords };
            return path(line) || null;
          } else {
            const a = projection(d.srcLL);
            const b = projection(d.dstLL);
            const [x1,y1] = a, [x2,y2] = b;
            const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
            const dx = x2 - x1, dy = y2 - y1;
            const norm = Math.sqrt(dx*dx + dy*dy) || 1;
            const base = Math.min(80, norm * 0.3);
            const horiz = Math.abs(dx) / norm;
            const off = base * horiz;
            let px = -dy / norm, py = dx / norm; // perpendiculaire +90°
            if (py > 0) { px = -px; py = -py; } // garantir une composante y négative (vers le haut)
            const cx = mx + px * off;
            const cy = my + py * off;
            return `M${x1},${y1} Q${cx},${cy} ${x2},${y2}`;
          }
        })
        .on('mouseenter', (ev, d) => {
          const key = normalizeName(d.dst);
          setHighlight(key);
        })
        .on('mousemove', (ev, d) => {
          tip.style.display = 'block';
          tip.style.left = (ev.clientX + 12) + 'px';
          tip.style.top = (ev.clientY + 12) + 'px';
          const v = d.views || 0;
          tip.textContent = `${d.src} → ${d.dst}: ${d.count} vidéos, ${d3.format(',')(v)} vues`;
        })
        .on('mouseleave', ()=>{ tip.style.display = 'none'; setHighlight(null); });

      // Cercles pour les flux où src == dst (comptage de vidéos distinctes au jour sélectionné)
      const selfFlows = flows.filter(d => normalizeName(d.src) === normalizeName(d.dst));
      const maxSelf = d3.max(selfFlows, d => d.count || 0) || 1;
      const rSelf = d3.scaleSqrt().domain([1, maxSelf]).range([3, 16]);
      const points = selfFlows.map(d => {
        const ll = countryLonLat(geo, d.dst);
        if(!ll || !isVisibleLonLat(ll)) return null;
        const c = projection(ll);
        return { x:c[0], y:c[1], country:d.dst, count:d.count };
      }).filter(Boolean);

      g.selectAll('circle.self-flow').data(points).join('circle')
        .attr('class', 'self-flow')
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('r', d => rSelf(d.count||0))
        .attr('fill', '#22c55e')
        .attr('fill-opacity', 0.28)
        .attr('stroke', '#22c55e')
        .attr('stroke-width', 1)
        .on('mouseenter', (ev, d) => { setHighlight(normalizeName(d.country)); })
        .on('mousemove', (ev, d) => {
          tip.style.display = 'block';
          tip.style.left = (ev.clientX + 12) + 'px';
          tip.style.top = (ev.clientY + 12) + 'px';
          tip.textContent = `${d.country}: ${d.count} vidéo(s)`;
        })
        .on('mouseleave', ()=>{ tip.style.display = 'none'; setHighlight(null); });
    }

    // Rendu statique dans un calque dédié, pour crossfade (sans interactions)
    function renderSnapshot(geo, flows, mode, targetG){
      targetG.selectAll('*').remove();
      // config locale de projection
      const proj = (mode === 'globe')
        ? d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate(projection.rotate())
        : d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]);
      const pth = d3.geoPath(proj);

      const localIsVisible = (lonlat) => {
        if(!lonlat) return false;
        if (mode === 'map') return true;
        const rot = d3.geoRotation(proj.rotate());
        const pp = rot(lonlat);
        return d3.geoDistance([0,0], pp) <= Math.PI/2 - 1e-6;
      };

      const countryLL = (name) => {
        const key = normalizeName(name);
        if (key && anchorOverrides[key]) return anchorOverrides[key];
        for(const f of geo.features){
          const nm = normalizeName(f.properties && f.properties.name);
          if(nm === key){ return d3.geoCentroid(f); }
        }
        return null;
      };

      targetG.append('path')
        .datum({type:'Sphere'})
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937')
        .attr('stroke-width', .8)
        .attr('d', pth);
      targetG.append('path')
        .datum(d3.geoGraticule10())
        .attr('fill', 'none')
        .attr('stroke', '#1f2937')
        .attr('stroke-opacity', 0.6)
        .attr('stroke-width', .5)
        .attr('d', pth);
      targetG.selectAll('path.country').data(geo.features).join('path')
        .attr('class', 'country')
        .attr('d', pth)
        .attr('data-key', d => normalizeName(d.properties && d.properties.name) || '')
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937').attr('stroke-width', .6);

      const maxCount = d3.max(flows, d => d.count || 0) || 1;
      const stroke = d3.scaleSqrt().domain([1, maxCount]).range([0.5, 0.5]);
      const opacity = d3.scaleSqrt().domain([1, maxCount]).range([0.25, 0.95]);

      const arcs = flows.map(d => {
        const srcLL = countryLL(d.src);
        const dstLL = countryLL(d.dst);
        if(!srcLL || !dstLL) return null;
        return { srcLL, dstLL, count: d.count, views: d.views, src: d.src, dst: d.dst };
      }).filter(Boolean);

      targetG.selectAll('path.flow').data(arcs).join('path')
        .attr('class', 'flow')
        .attr('fill', 'none')
        .attr('stroke', '#22c55e')
        .attr('stroke-opacity', d => opacity(d.count||0))
        .attr('stroke-width', d => stroke(d.count||0))
        .attr('d', d => {
          if (mode === 'globe'){
            const interpolate = d3.geoInterpolate(d.srcLL, d.dstLL);
            const dist = d3.geoDistance(d.srcLL, d.dstLL);
            const steps = Math.max(8, Math.ceil(dist * 32));
            const coords = d3.range(steps + 1).map(t => interpolate(t/steps));
            const line = { type:'LineString', coordinates: coords };
            return pth(line) || null;
          } else {
            const a = proj(d.srcLL);
            const b = proj(d.dstLL);
            const [x1,y1] = a, [x2,y2] = b;
            const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
            const dx = x2 - x1, dy = y2 - y1;
            const norm = Math.sqrt(dx*dx + dy*dy) || 1;
            const base = Math.min(80, norm * 0.3);
            const horiz = Math.abs(dx) / norm;
            const off = base * horiz;
            let px = -dy / norm, py = dx / norm;
            if (py > 0) { px = -px; py = -py; }
            const cx = mx + px * off;
            const cy = my + py * off;
            return `M${x1},${y1} Q${cx},${cy} ${x2},${y2}`;
          }
        });

      const selfFlows = flows.filter(d => normalizeName(d.src) === normalizeName(d.dst));
      const maxSelf = d3.max(selfFlows, d => d.count || 0) || 1;
      const rSelf = d3.scaleSqrt().domain([1, maxSelf]).range([3, 16]);
      const points = selfFlows.map(d => {
        const ll = countryLL(d.dst);
        if(!ll || !localIsVisible(ll)) return null;
        const c = proj(ll);
        return { x:c[0], y:c[1], country:d.dst, count:d.count };
      }).filter(Boolean);

      targetG.selectAll('circle.self-flow').data(points).join('circle')
        .attr('class', 'self-flow')
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('r', d => rSelf(d.count||0))
        .attr('fill', '#22c55e')
        .attr('fill-opacity', 0.28)
        .attr('stroke', '#22c55e')
        .attr('stroke-width', 1);
    }

    async function init(){
      const [geo, dateList] = await Promise.all([
        loadWorld(),
        fetch(`/api/meta/dates`).then(r=>r.json()).catch(()=>({dates:[]}))
      ]);
      worldGeo = geo;
      dates = (dateList && Array.isArray(dateList.dates)) ? dateList.dates : [];
      dateSlider.min = 0; dateSlider.max = Math.max(0, dates.length-1); dateSlider.value = Math.max(0, dates.length-1);
      dateLabel.textContent = dates.length ? dates[+dateSlider.value] : '—';
      // Charger les pays source
      const channels = await fetch('/api/meta/channels').then(r=>r.json()).catch(()=>({countries:[]}));
      const countries = (channels && Array.isArray(channels.countries)) ? channels.countries : [];
      srcSelect.replaceChildren(...countries.map(c => {
        const opt = document.createElement('option');
        opt.value = c; opt.textContent = c; return opt;
      }));
      // Sélection par défaut: France
      const franceOpt = Array.from(srcSelect.options).find(o => (o.value||'').toLowerCase() === 'france');
      if(franceOpt){ srcSelect.value = franceOpt.value; }
      const [flows, vids] = await Promise.all([fetchFlows(), fetchVideos()]);
      lastFlows = flows;
      render(geo, flows);
      const fmt0 = d3.format(',');
      videoList.replaceChildren(...(vids.map(v => {
        const row = document.createElement('div');
        row.style.display = 'grid';
        row.style.gridTemplateColumns = '1fr auto auto';
        row.style.gap = '8px';
        const title = document.createElement('div');
        title.textContent = v.video_title || v.video_id;
        const views = document.createElement('div');
        views.textContent = `${fmt0(v.views||0)} vues`;
        views.style.color = '#9ca3af';
        const likes = document.createElement('div');
        likes.textContent = `${fmt0(v.likes||0)} likes`;
        likes.style.color = '#9ca3af';
        row.appendChild(title); row.appendChild(views); row.appendChild(likes);
        return row;
      })));

      // Zoom & drag dépendants de la projection
      let dragEnabled = false;
      function setupInteractions(){
        // nettoyer anciens handlers
        svg.on('.zoom', null).on('.drag', null);
        if (projectionMode === 'globe'){
          // reset transform
          g.attr('transform', null);
          currentZoomK = Math.max(0.7, Math.min(12, currentZoomK));
          projection.scale(baseScaleGlobe * currentZoomK);
          zoomBehavior = d3.zoom()
            .scaleExtent([0.7, 12])
            .filter((event) => event.type === 'wheel')
            .on('zoom', (ev) => {
              currentZoomK = ev.transform.k;
              projection.scale(baseScaleGlobe * currentZoomK);
              render(geo, lastFlows);
            });
          svg.call(zoomBehavior).on('dblclick.zoom', null);

          dragBehavior = d3.drag()
            .filter((event) => dragEnabled && event.button === 0)
            .on('start', (ev) => {
              svg.style('cursor','grabbing');
              dragBehavior.__start = { x: ev.x, y: ev.y, r: projection.rotate() };
            })
            .on('drag', (ev) => {
              const s = dragBehavior.__start || { x: ev.x, y: ev.y, r: projection.rotate() };
              const dx = ev.x - s.x;
              const dy = ev.y - s.y;
              const sens = 0.25; // degrés par pixel
              const r0 = s.r || [0,0,0];
              const r = [ r0[0] + dx * sens, r0[1] - dy * sens, r0[2] || 0 ];
              projection.rotate(r);
              render(geo, lastFlows);
            })
            .on('end', () => { svg.style('cursor', dragEnabled ? 'grab' : 'default'); });
          svg.call(dragBehavior);
        } else {
          // mode carte: zoom/pan via transform, projection à l'échelle base
          projection = d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]);
          path = d3.geoPath(projection);
          zoomBehavior = d3.zoom()
            .scaleExtent([0.7, 12])
            .filter((event) => {
              if (event.type === 'wheel') return true;
              if (event.type === 'mousedown') return dragEnabled && event.button === 0;
              return false;
            })
            .on('start', () => { if (dragEnabled) svg.style('cursor','grabbing'); })
            .on('end',   () => { svg.style('cursor', dragEnabled ? 'grab' : 'default'); })
            .on('zoom', (ev) => { g.attr('transform', ev.transform); });
          svg.call(zoomBehavior).on('dblclick.zoom', null);
        }
      }

      // Bouton de réinitialisation de la vue
      const btnReset = document.getElementById('resetView');
      function resetView(){ svg.transition().duration(350).call(zoom.transform, d3.zoomIdentity); }
      btnReset.addEventListener('click', resetView);

      // Bouton toggle drag
      const btnDrag = document.getElementById('toggleDrag');
      function updateDragUI(){
        btnDrag.classList.toggle('is-on', dragEnabled);
        svg.style('cursor', dragEnabled ? 'grab' : 'default');
      }
      updateDragUI();
      btnDrag.addEventListener('click', () => {
        dragEnabled = !dragEnabled;
        updateDragUI();
      });

      function setProjectionMode(mode){
        const prevMode = projectionMode;
        const prevRotate = (typeof projection.rotate === 'function') ? projection.rotate() : [0,0,0];
        // Morphing réel des chemins entre prevMode -> mode
        morphProjection(prevMode, mode, prevRotate);
      }

      function morphProjection(prevMode, targetMode, prevRotate){
        // désactiver interactions pendant morph
        svg.on('.zoom', null).on('.drag', null);

        // Capturer le transform actuel avant de le modifier
        const currentTransform = d3.zoomTransform(svg.node());

        // Créer les projections source et cible avec gestion cohérente des échelles
        let proj0, proj1;
        
        if (prevMode === 'globe') {
          proj0 = d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate(prevRotate);
        } else {
          // En mode carte, créer une projection qui reflète l'état visuel actuel
          const yaw = (Array.isArray(prevRotate) ? prevRotate[0] : 0) || 0;
          proj0 = d3.geoNaturalEarth1().scale(baseScaleMap * currentTransform.k).translate([
            width/2 + currentTransform.x, 
            height/2 + currentTransform.y
          ]).rotate([yaw, 0, 0]);
        }
          
        if (targetMode === 'globe') {
          proj1 = d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate(prevRotate);
        } else {
          const yaw = (Array.isArray(prevRotate) ? prevRotate[0] : 0) || 0;
          proj1 = d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]).rotate([yaw, 0, 0]);
        }

        projectionMode = 'blend';
        const dur = 1200;

        // Supprimer le transform immédiatement pour éviter les conflits
        g.attr('transform', null);

        // Créer une transition unique et cohérente pour tous les éléments
        const transition = g.transition().duration(dur).ease(d3.easeQuadInOut);

        // Méthode standard D3 (ObservableHQ) : interpolation point par point entre projections
        const createPathTween = (geom) => {
          return (t) => {
            const interpolatedProj = d3.geoProjection((lambda, phi) => {
              const lonlat = [lambda * 180 / Math.PI, phi * 180 / Math.PI];
              const p0 = proj0(lonlat);
              const p1 = proj1(lonlat);
              if (!p0 || !p1) return null;
              return [
                p0[0] + t * (p1[0] - p0[0]), 
                p0[1] + t * (p1[1] - p0[1])
              ];
            }).scale(1);
            
            // Ne pas interpoler la rotation pour éviter un saut d'orientation
            
            return d3.geoPath(interpolatedProj)(geom);
          };
        };

        // Animer tous les pays
        transition.selectAll('path.country')
          .attrTween('d', function(d) { return createPathTween(d); });

        // Animer la sphère
        transition.selectAll('path')
          .filter((d) => d && d.type === 'Sphere')
          .attrTween('d', function(d) { return createPathTween(d); });

        // Animer le graticule
        const graticule = d3.geoGraticule10();
        transition.selectAll('path')
          .filter((d) => d && d.type === 'MultiLineString')
          .attrTween('d', function() { return createPathTween(graticule); });

        // Animer les flows (toujours en géodésiques pour la cohérence)
        transition.selectAll('path.flow')
          .attrTween('d', function(d) {
            return (t) => {
              const interpolate = d3.geoInterpolate(d.srcLL, d.dstLL);
              const dist = d3.geoDistance(d.srcLL, d.dstLL);
              const steps = Math.max(8, Math.ceil(dist * 20));
              const coords = d3.range(steps + 1).map(s => interpolate(s/steps));
              const line = { type:'LineString', coordinates: coords };
              return createPathTween(line)(t);
            };
          });

        // Animer les points self-flow
        transition.selectAll('circle.self-flow')
          .attrTween('cx', function(d){
            const ll = countryLonLat(worldGeo, d.country);
            if (!ll) return null;
            return (t) => {
              const p0 = proj0(ll);
              const p1 = proj1(ll);
              if (!p0 || !p1) return null;
              return p0[0] + t * (p1[0] - p0[0]);
            };
          })
          .attrTween('cy', function(d){
            const ll = countryLonLat(worldGeo, d.country);
            if (!ll) return null;
            return (t) => {
              const p0 = proj0(ll);
              const p1 = proj1(ll);
              if (!p0 || !p1) return null;
              return p0[1] + t * (p1[1] - p0[1]);
            };
          });

        // À la fin de la transition
        transition.on('end', () => {
          projectionMode = targetMode;
          projection = proj1;
          path = d3.geoPath(proj1);
          setupInteractions();
          render(worldGeo, lastFlows);
          updateProjectionUI();
        });
      }

      function updateProjectionUI(){
        toggleProjectionBtn.textContent = (projectionMode === 'globe') ? 'GLOBE' : 'MAP';
      }
      updateProjectionUI();
      toggleProjectionBtn.addEventListener('click', () => {
        const next = (projectionMode === 'globe') ? 'map' : 'globe';
        setProjectionMode(next);
      });

      // initialiser interactions selon mode courant
      setupInteractions();

      const refresh = async () => {
        const [fl, vids] = await Promise.all([fetchFlows(), fetchVideos()]);
        lastFlows = fl;
        render(geo, fl);
        const fmt = d3.format(',');
        videoList.replaceChildren(...(vids.map(v => {
          const row = document.createElement('div');
          row.style.display = 'grid';
          row.style.gridTemplateColumns = '1fr auto auto';
          row.style.gap = '8px';
          const title = document.createElement('div');
          title.textContent = v.video_title || v.video_id;
          const views = document.createElement('div');
          views.textContent = `${fmt(v.views||0)} vues`;
          views.style.color = '#9ca3af';
          const likes = document.createElement('div');
          likes.textContent = `${fmt(v.likes||0)} likes`;
          likes.style.color = '#9ca3af';
          row.appendChild(title); row.appendChild(views); row.appendChild(likes);
          return row;
        })));
      };
      // Source fixe: yt_clean (pas d'écouteur de changement de table)
      dateSlider.addEventListener('input', async ()=>{
        dateLabel.textContent = dates.length ? dates[+dateSlider.value] : '—';
        await refresh();
      });
      srcSelect.addEventListener('change', refresh);
      toggleModeBtn.addEventListener('click', async () => {
        mode = (mode === 'off') ? 'on' : 'off';
        toggleModeBtn.textContent = mode.toUpperCase();
        await refresh();
      });
    }
    init();
  </script>
</body>
</html>


