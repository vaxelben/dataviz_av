<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flux pays (channel_country → trending_country)</title>
  <style>
    :root { --bg:#0f172a; --panel:#0b1220; --text:#e5e7eb; --muted:#9ca3af; --border:#1f2937; }
    *{box-sizing:border-box}
    html, body { height:100%; }
    body{margin:0;background:var(--bg);color:var(--text);font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; overflow:hidden}
    header{display:none}
    main{padding:0; height:100%;}
    .row{display:grid; grid-template-columns: 1fr 360px; gap:0; height:100%;}
    #mapPanel{ padding:0; display:flex; flex-direction:column; min-height:0; }
    #filterPanel{ background:transparent; border:none; border-radius:0; padding:12px; }
    .panel{ background:transparent; border:none; border-radius:0; }
    #map{ width:100%; height:auto; min-height:0; position: relative; flex:1 1 0; }
    #chart{ width:100%; border-top:1px solid var(--border); flex:0 0 33vh; min-height:33vh; }
    #map svg{ cursor: default; }
    .btn-reset{ position:absolute; top:12px; left:12px; width:36px; height:36px; display:grid; place-items:center; border:1px solid var(--border); background:#0b1220aa; color:var(--text); border-radius:8px; cursor:pointer; z-index:5; }
    .btn-reset:hover{ background:#111827; }
    .btn-drag{ position:absolute; top:12px; left:56px; width:36px; height:36px; display:grid; place-items:center; border:1px solid var(--border); background:#0b1220aa; color:var(--text); border-radius:8px; cursor:pointer; z-index:5; }
    .btn-drag:hover{ background:#111827; }
    .btn-drag.is-on{ outline:2px solid #22c55e; }
    .btn-proj{ position:absolute; top:12px; left:100px; min-width:78px; height:36px; display:grid; place-items:center; padding:0 10px; border:1px solid var(--border); background:#0b1220aa; color:var(--text); border-radius:8px; cursor:pointer; z-index:5; }
    .btn-proj:hover{ background:#111827; }
    label{display:block;margin-bottom:8px;color:var(--muted);font-size:13px}
    select,input{width:100%;padding:8px 10px;background:#0f172a;border:1px solid var(--border);border-radius:8px;color:var(--text)}
    .tooltip{position:fixed;pointer-events:none;background:#111827;border:1px solid var(--border);padding:8px 10px;border-radius:8px;font-size:12px;color:var(--text);display:none}
    .country{ transition: fill .18s ease, stroke .18s ease, stroke-width .18s ease; }
    .country.hl{ fill:#162033; stroke:#22c55e; stroke-width:1.0; }
    .country.sel{ fill:#22c55ea5; }
    .country.dst{ fill:#22c55e30; }
    /* Icône de lien bleu clair par défaut, plus bleue au survol */
    .link-icon{ filter: hue-rotate(200deg) saturate(180%) brightness(1.0); opacity: .9; transition: filter .15s ease, opacity .15s ease; }
    a:hover .link-icon{ filter: hue-rotate(200deg) saturate(280%) brightness(1.08); opacity: 1; }
  </style>
</head>
<body>
  <header>
    <div>Flux entre pays: channel_country → video_trending_country</div>
    <a href="/">Retour</a>
  </header>
  <main>
    <div class="row">
      <div class="panel" id="mapPanel">
        <div id="map">
          <button id="resetView" class="btn-reset" title="Réinitialiser la vue" aria-label="Réinitialiser la vue">⟲</button>
          <button id="toggleDrag" class="btn-drag" title="Activer/Désactiver le déplacement" aria-label="Activer/Désactiver le déplacement">✥</button>
          <button id="toggleProjection" class="btn-proj" title="Basculer projection" aria-label="Basculer projection"></button>
        </div>
        <div id="chart"></div>
      </div>
      <div class="panel" id="filterPanel" style="display:flex;flex-direction:column;gap:12px;overflow:auto">
        <div style="display:flex;align-items:center;gap:8px">
          <button id="toggleMode" title="Basculer mode flux" aria-label="Basculer mode" style="min-width:64px;border:1px solid var(--border);background:#0b1220aa;color:var(--text);border-radius:8px;padding:6px 10px;cursor:pointer">ON</button>
          <div class="muted">Mode: OFF = domestique (src = dst), ON = international (src ≠ dst)</div>
        </div>
        <!-- Source unique: yt_clean -->
        <label style="margin-top:10px">Date (video_trending_date)</label>
        <input id="dateSlider" type="range" min="0" max="0" step="1" value="0" style="width:100%" />
        <div class="muted" id="dateLabel" style="margin-top:6px">—</div>
        <label style="margin-top:12px">channel_country</label>
        <select id="srcCountries" style="width:100%"></select>
        <div style="border-top:1px solid var(--border); padding-top:10px"></div>
        <div class="muted">Vidéos sélectionnées</div>
        <div id="videoList" style="font-size:12px; line-height:1.35; max-height:40vh; overflow:auto; border:1px solid var(--border); border-radius:8px; padding:8px"></div>
      </div>
    </div>
  </main>
  <div class="tooltip" id="tip"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <script>
    const $ = s => document.querySelector(s);
    const tip = $('#tip');
    
    // Fonction pour convertir une date YYYY-MM-DD en format français dd/MM/yyyy
    function formatDateFrench(dateStr) {
      if (!dateStr) return dateStr;
      const parts = dateStr.split('-');
      if (parts.length === 3) {
        return `${parts[2]}/${parts[1]}/${parts[0]}`;
      }
      return dateStr;
    }

    const width = 980, height = 540;
    const svg = d3.select('#map').append('svg').attr('viewBox', `0 0 ${width} ${height}`).style('width','100%').style('height','100%');
    const g = svg.append('g');
    let projectionMode = 'globe';
    const baseScaleGlobe = 240;
    const baseScaleMap = 165;
    let currentZoomK = 1;
    let projection = d3.geoOrthographic().scale(baseScaleGlobe).translate([width/2, height/2]).clipAngle(90);
    let path = d3.geoPath(projection);
    let blendProjectFn = null; // fonction de projection interpolée pendant le morphing
    let blendT = 0;            // progression du morphing [0..1]
    let worldGeo = null;       // géo conservée pour morphing

    // Fonction de comparaison simple (noms identiques entre DB et world-atlas)
    function normalizeName(s){
      if(!s) return null;
      return String(s).trim();
    }

    async function loadWorld(){
      const topo = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json').then(r=>r.json());
      const geo = topojson.feature(topo, topo.objects.countries);
      
      // Chargement des pays depuis world-atlas
      
      return geo;
    }

    let dates = [];
    const dateSlider = document.getElementById('dateSlider');
    const dateLabel = document.getElementById('dateLabel');
    const srcSelect = document.getElementById('srcCountries');
    const videoList = document.getElementById('videoList');
    const toggleModeBtn = document.getElementById('toggleMode');
    const toggleProjectionBtn = document.getElementById('toggleProjection');
    const projIcon = document.createElement('img');
    projIcon.width = 20;
    projIcon.height = 20;
    projIcon.alt = '';
    toggleProjectionBtn.textContent = '';
    toggleProjectionBtn.appendChild(projIcon);
    let mode = 'on'; // 'off' = domestique (src=dst), 'on' = international (src!=dst)
    let lastFlows = [];
    let zoomBehavior = null;
    let dragBehavior = null;
    let selectedVideoId = null;
    let selectedVideoData = null;
    let videosCache = [];
    const chartDiv = document.getElementById('chart');
    let filterListToSelection = false;
    let arcHover = null; // { srcKey, dstKey }
    let arcFilter = null; // { srcKey, dstKey }
    let chartFollowSelection = true; // Quand false, ne pas toucher au graphe en lignes

    function flowsForSelectedVideo(){
      if (!selectedVideoData) return [];
      return [{ src: selectedVideoData.src, dst: selectedVideoData.dst, count: 1, views: selectedVideoData.views }];
    }

    async function fetchFlows(){
      const qs = new URLSearchParams();
      if(dates.length){
        const idx = +dateSlider.value || 0;
        const onDate = dates[Math.max(0, Math.min(idx, dates.length-1))];
        if(onDate) qs.set('onDate', onDate);
      }
      const selected = srcSelect.value;
      if(selected){ qs.set('src', selected); }
      if(mode){ qs.set('mode', mode); }
      const res = await fetch(`/api/flow/country?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data;
    }

    async function fetchVideos(){
      const qs = new URLSearchParams();
      if(dates.length){
        const idx = +dateSlider.value || 0;
        const onDate = dates[Math.max(0, Math.min(idx, dates.length-1))];
        if(onDate) qs.set('onDate', onDate);
      }
      const selected = srcSelect.value;
      if(selected){ qs.set('src', selected); }
      if(mode){ qs.set('mode', mode); }
      const res = await fetch(`/api/videos?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data || [];
    }

    async function fetchAllVideos(){
      const qs = new URLSearchParams();
      const selected = srcSelect.value;
      if(selected){ qs.set('src', selected); }
      if(mode){ qs.set('mode', mode); }
      const res = await fetch(`/api/videos/all?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data || [];
    }

    async function fetchVideosByFlow(srcKey, dstKey){
      const qs = new URLSearchParams();
      if(dates.length){
        const idx = +dateSlider.value || 0;
        const onDate = dates[Math.max(0, Math.min(idx, dates.length-1))];
        if(onDate) qs.set('onDate', onDate);
      }
      if (srcKey) qs.set('src', srcKey);
      if (dstKey) qs.set('dst', dstKey);
      if(mode){ qs.set('mode', mode); }
      const res = await fetch(`/api/videos/by_flow?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data || [];
    }

    async function fetchFlowsByVideo(videoId, includeDate = false){
      const qs = new URLSearchParams();
      if (videoId) qs.set('videoId', videoId);
      // Ne filtrer par date que si explicitement demandé
      if(includeDate && dates.length){
        const idx = +dateSlider.value || 0;
        const onDate = dates[Math.max(0, Math.min(idx, dates.length-1))];
        if(onDate) qs.set('onDate', onDate);
      }
      if(mode){ qs.set('mode', mode); }
      const res = await fetch(`/api/flow/video?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data || [];
    }

    async function fetchVideoViewsTimeline(videoId){
      if (!videoId) return [];
      const qs = new URLSearchParams();
      qs.set('videoId', videoId);
      if (mode) qs.set('mode', mode);
      const res = await fetch(`/api/video/views_timeline?${qs.toString()}`);
      const js = await res.json();
      if(!res.ok) throw new Error(js.error||'Erreur API');
      return js.data || [];
    }

    async function fetchTimelinesForVideos(vids, limit = 20){
      const ids = (vids || []).map(v => v.video_id).filter(Boolean).slice(0, limit);
      const results = await Promise.all(ids.map(async (id) => {
        const data = await fetchVideoViewsTimeline(id);
        return { videoId: id, data };
      }));
      return results;
    }

    // Cache global des timelines pour éviter les requêtes répétées
    let globalTimelinesCache = new Map();
    let isPreloading = false;

    async function loadMoreTimelines(vids, currentCount = 10) {
      const allVideoIds = (vids || []).map(v => v.video_id).filter(Boolean);
      const missingIds = allVideoIds.filter(id => !globalTimelinesCache.has(id));
      
      if (missingIds.length > 0) {
        const batch = missingIds.slice(0, Math.min(currentCount, 50));
        const newTimelines = await fetchTimelinesForVideos(batch.map(id => ({video_id: id})), batch.length);
        newTimelines.forEach(tl => {
          if (tl.videoId) globalTimelinesCache.set(tl.videoId, tl);
        });
      }
      
      return allVideoIds.map(id => globalTimelinesCache.get(id)).filter(Boolean);
    }

    // Préchargement en arrière-plan pour améliorer la réactivité
    async function preloadTimelines(vids, delay = 200) {
      if (isPreloading) return;
      isPreloading = true;
      
      setTimeout(async () => {
        try {
          const allVideoIds = (vids || []).map(v => v.video_id).filter(Boolean);
          const missingIds = allVideoIds.filter(id => !globalTimelinesCache.has(id));
          
          if (missingIds.length > 0) {
            const batch = missingIds.slice(0, 20); // Précharger 20 de plus
            const newTimelines = await fetchTimelinesForVideos(batch.map(id => ({video_id: id})), batch.length);
            newTimelines.forEach(tl => {
              if (tl.videoId) globalTimelinesCache.set(tl.videoId, tl);
            });
          }
        } catch (e) {
          console.warn('Préchargement échoué:', e);
        }
        isPreloading = false;
      }, delay);
    }

    function renderViewsChartMulti(seriesList, highlightVideoId = null){
      chartDiv.replaceChildren();
      // Nettoyer les infobulles existantes
      d3.selectAll('.chart-tooltip').remove();
      const list = Array.isArray(seriesList) ? seriesList : [];
      if (!list.length) return;
      const m = {t:20, r:16, b:24, l:40}; // Augmenter la marge du haut pour les labels de date
      const w = chartDiv.clientWidth || width;
      const h = chartDiv.clientHeight || 320;
      const svgC = d3.select(chartDiv).append('svg').attr('width', '100%').attr('height', '100%').attr('viewBox', `0 0 ${w} ${h}`);
      const gx = svgC.append('g').attr('transform', `translate(${m.l},${m.t})`);
      const innerW = w - m.l - m.r;
      const innerH = h - m.t - m.b;
      const parse = d3.utcParse('%Y-%m-%d');
      const seriesParsed = list.map(s => ({
        videoId: s.videoId,
        pts: (s.data||[]).map(d => ({ d: parse(d.date), v: +d.views||0 })).filter(d => d.d)
      })).filter(s => s.pts.length);
      if (!seriesParsed.length) return;
      const allPts = seriesParsed.flatMap(s => s.pts);
      const x = d3.scaleUtc().domain(d3.extent(allPts, d => d.d)).range([0, innerW]);
      if (Array.isArray(dates) && dates.length){
        const dmin = parse(dates[0]);
        const dmax = parse(dates[dates.length-1]);
        if (dmin && dmax) x.domain([dmin, dmax]);
      }
      const y = d3.scaleSqrt().domain([0, d3.max(allPts, d => d.v)||1]).nice().range([innerH, 0]);
      const ax = d3.axisBottom(x).ticks(5).tickSizeOuter(0).tickFormat(d3.utcFormat('%d/%m/%Y'));
      const ay = d3.axisLeft(y).ticks(4).tickSize(-innerW).tickFormat(d3.format('.2s'));
      gx.append('g').attr('transform', `translate(0,${innerH})`).call(ax).selectAll('text').attr('fill', '#9ca3af');
      gx.append('g').call(ay).call(g => g.selectAll('text').attr('fill', '#9ca3af')).call(g => g.selectAll('line').attr('stroke', '#1f2937')).call(g => g.select('.domain').attr('stroke', '#1f2937'));
      
      // Ajouter la ligne de référence pour la date sélectionnée
      if (dates.length && dateSlider) {
        const selectedDateIdx = +dateSlider.value || 0;
        const selectedDate = dates[Math.max(0, Math.min(selectedDateIdx, dates.length-1))];
        if (selectedDate) {
          const selectedDateParsed = parse(selectedDate);
          if (selectedDateParsed) {
            const xPos = x(selectedDateParsed);
            // Ligne verticale de référence
            gx.append('line')
              .attr('class', 'date-reference-line')
              .attr('x1', xPos)
              .attr('x2', xPos)
              .attr('y1', 0)
              .attr('y2', innerH)
              .attr('stroke', '#ef4444')
              .attr('stroke-width', 2)
              .attr('stroke-dasharray', '4,4')
              .attr('opacity', 0.8);
            
            // Label de la date
            gx.append('text')
              .attr('class', 'date-reference-label')
              .attr('x', xPos)
              .attr('y', -5)
              .attr('text-anchor', 'middle')
              .attr('fill', '#ef4444')
              .attr('font-size', '11px')
              .attr('font-weight', 'bold')
              .text(formatDateFrench(selectedDate));
          }
        }
      }
      
      // Barre de référence pour le survol de la souris
      const hoverLine = gx.append('line')
        .attr('class', 'hover-reference-line')
        .attr('y1', 0)
        .attr('y2', innerH)
        .attr('stroke', '#94a3b8')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '2,2')
        .attr('opacity', 0)
        .style('pointer-events', 'none');

      const hoverDateLabel = gx.append('text')
        .attr('class', 'hover-reference-date')
        .attr('y', -8)
        .attr('text-anchor', 'middle')
        .attr('font-size', '10px')
        .attr('fill', '#94a3b8')
        .attr('opacity', 0)
        .style('pointer-events', 'none');

      // Zone invisible pour capturer le survol sur tout le graphique
      gx.append('rect')
        .attr('class', 'hover-capture')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', innerW)
        .attr('height', innerH)
        .attr('fill', 'transparent')
        .style('pointer-events', 'all')
        .on('mousemove', function(event) {
          const [mouseX] = d3.pointer(event, this);
          const hoveredDate = x.invert(mouseX);
          
          // Ajuster la position de la ligne de référence
          const refX = x(hoveredDate);
          hoverLine
            .attr('x1', refX)
            .attr('x2', refX)
            .attr('opacity', 0.6);
          
          // Ajuster la position et le texte du label
          const formatDate = d3.utcFormat('%d/%m/%Y');
          hoverDateLabel
            .attr('x', refX)
            .attr('opacity', 0.8)
            .text(formatDate(hoveredDate));
        })
        .on('mouseleave', function() {
          hoverLine.attr('opacity', 0);
          hoverDateLabel.attr('opacity', 0);
        });
      
      const line = d3.line().x(d => x(d.d)).y(d => y(d.v)).curve(d3.curveMonotoneX);
      
      // Créer une infobulle pour le graphique
      const chartTooltip = d3.select('body').append('div')
        .attr('class', 'chart-tooltip')
        .style('position', 'absolute')
        .style('background', '#1f2937')
        .style('color', 'white')
        .style('padding', '8px 12px')
        .style('border-radius', '4px')
        .style('font-size', '12px')
        .style('pointer-events', 'none')
        .style('opacity', 0)
        .style('z-index', '1000');

      const svgNode = svgC.node();
      function positionChartTooltip(pageX, pageY){
        if (!svgNode) return;
        const rect = svgNode.getBoundingClientRect();
        const ttEl = chartTooltip.node();
        if (!ttEl) return;
        const padding = 8; // marge aux bords du SVG
        const cursorMarginX = 16; // marge horizontale depuis le curseur
        const cursorMarginY = 14; // marge verticale depuis le curseur
        const scrollX = window.pageXOffset || document.documentElement.scrollLeft || 0;
        const scrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
        const svgLeft = rect.left + scrollX;
        const svgTop = rect.top + scrollY;
        const svgRight = rect.right + scrollX;
        const svgBottom = rect.bottom + scrollY;
        const ttW = ttEl.offsetWidth || 0;
        const ttH = ttEl.offsetHeight || 0;
        // Position préférée: en bas à droite du curseur, avec marge de sécurité
        let left = pageX + cursorMarginX;
        let top = pageY + cursorMarginY;
        // Flip horizontal si dépassement à droite
        if (left + ttW + padding > svgRight) {
          left = pageX - ttW - cursorMarginX;
        }
        // Flip vertical si dépassement en bas
        if (top + ttH + padding > svgBottom) {
          top = pageY - ttH - cursorMarginY;
        }
        // Clamp final aux limites du SVG
        if (left < svgLeft + padding) left = svgLeft + padding;
        if (top < svgTop + padding) top = svgTop + padding;
        if (left + ttW + padding > svgRight) left = svgRight - ttW - padding;
        if (top + ttH + padding > svgBottom) top = svgBottom - ttH - padding;
        chartTooltip.style('left', left + 'px').style('top', top + 'px');
      }
      
      // Obtenir la date sélectionnée par le slider
      const selectedDate = dates.length && dateSlider ? dates[+dateSlider.value || 0] : null;
      const selectedDateParsed = selectedDate ? parse(selectedDate) : null;
      
      // Fonction commune: appliquer le même filtrage qu'au clic sur une ligne
      async function applyVideoSelection(clickedVideoId){
        chartFollowSelection = true;
        arcFilter = null;
        if (selectedVideoId === clickedVideoId) {
          // Désélection -> restaurer la liste selon les filtres courants (date/src/mode) et graphe multi
          selectedVideoId = null; selectedVideoData = null;
          const vids = await fetchVideos();
          videosCache = vids;
          if (window.renderVideoList) window.renderVideoList(vids);
          if (window.highlightSelectedVideoRow) window.highlightSelectedVideoRow();
          if (window.refreshMapOnly) await window.refreshMapOnly();
          const series = await fetchTimelinesForVideos(vids, 20);
          renderViewsChartMulti(series, null);
        } else {
          // Sélection -> filtrer pour cette vidéo
          selectedVideoId = clickedVideoId;
          selectedVideoData = (videosCache||[]).find(v => v.video_id === clickedVideoId) || null;
          if (!selectedVideoData) {
            selectedVideoData = { video_id: clickedVideoId, video_title: `Vidéo ${clickedVideoId}` };
          }
          const filteredVideos = [selectedVideoData];
          if (window.renderVideoList) window.renderVideoList(filteredVideos);
          if (window.highlightSelectedVideoRow) window.highlightSelectedVideoRow();
          if (window.refreshMapOnly) await window.refreshMapOnly();
          const tl = await fetchVideoViewsTimeline(selectedVideoId);
          renderViewsChartMulti([{ videoId: selectedVideoId, data: tl }], selectedVideoId);
        }
      }

      // tracer toutes les séries
      seriesParsed.forEach(s => {
        const isHi = !!highlightVideoId && s.videoId === highlightVideoId;
        
        // Vérifier si cette série a un point à la date sélectionnée
        const hasSelectedDate = selectedDateParsed ? 
          s.pts.some(pt => Math.abs(pt.d.getTime() - selectedDateParsed.getTime()) < 24 * 60 * 60 * 1000) : 
          false;
        
        // Déterminer l'opacité : 0.1 par défaut, plus visible si elle contient la date sélectionnée
        let opacity = 0.1;
        if (isHi) opacity = 1; // Vidéo sélectionnée = complètement visible
        else if (hasSelectedDate) opacity = 0.6; // Contient la date du slider = visible
        
        // Ligne
        const p = gx.append('path')
          .datum(s.pts)
          .attr('class', 'series-line')
          .attr('data-video-id', s.videoId)
          .attr('fill', 'none')
          .attr('stroke', '#22c55e')
          .attr('stroke-opacity', opacity)
          .attr('stroke-width', isHi ? 3 : 2)
          .attr('d', line);
        
        // Points sur la ligne
        const videoData = (videosCache || []).find(v => v.video_id === s.videoId);
        const videoTitle = videoData ? videoData.video_title || s.videoId : s.videoId;
        
        gx.selectAll(`.point-${s.videoId}`)
          .data(s.pts)
          .join('circle')
          .attr('class', `point-${s.videoId} series-point`)
          .attr('data-video-id', s.videoId)
          .attr('cx', d => x(d.d))
          .attr('cy', d => y(d.v))
          .attr('r', isHi ? 2.5 : 2)
          .attr('fill', '#22c55e')
          .attr('fill-opacity', 0) // Points invisibles par défaut
          .style('cursor', 'pointer')
          .style('pointer-events', 'none') // Désactiver les événements sur les petits cercles
          
        // Ajouter une zone de survol invisible plus large pour chaque point
        gx.selectAll(`.hover-area-${s.videoId}`)
          .data(s.pts)
          .join('circle')
          .attr('class', `hover-area-${s.videoId} hover-area`)
          .attr('data-video-id', s.videoId)
          .attr('cx', d => x(d.d))
          .attr('cy', d => y(d.v))
          .attr('r', 8) // Zone de survol plus large (8px de rayon)
          .attr('fill', 'transparent')
          .attr('stroke', 'none')
          .style('cursor', 'pointer')
          .style('pointer-events', 'all')
          .on('mouseenter', function(event, d) {
            // Rendre le point visible au survol (chercher le point correspondant à cette position exacte)
            const currentDate = d.d;
            gx.selectAll(`.point-${s.videoId}`)
              .filter(function(pointData) {
                return pointData.d.getTime() === currentDate.getTime();
              })
              .attr('fill-opacity', 0.7);
            
            const formatDate = d3.utcFormat('%d/%m/%Y');
            const formatViews = d3.format(',');
            chartTooltip
              .style('opacity', 1)
              .html(`<strong>ID:</strong> ${s.videoId}<br/><strong>${videoTitle}</strong><br/>Date: ${formatDate(d.d)}<br/>Vues: ${formatViews(d.v)}`)
            positionChartTooltip(event.pageX, event.pageY);
          })
          .on('mousemove', function(event) {
            positionChartTooltip(event.pageX, event.pageY);
          })
          .on('mouseleave', function(event, d) {
            // Rendre le point invisible quand on quitte le survol
            const currentDate = d.d;
            gx.selectAll(`.point-${s.videoId}`)
              .filter(function(pointData) {
                return pointData.d.getTime() === currentDate.getTime();
              })
              .attr('fill-opacity', 0); // Toujours invisible au départ de la souris
            
            chartTooltip.style('opacity', 0);
          })
          .on('click', async function(event) {
            // Empêcher immédiatement la propagation pour éviter le handler de fond
            if (event && typeof event.stopPropagation === 'function') event.stopPropagation();
            if (event && typeof event.preventDefault === 'function') event.preventDefault();
            const videoId = d3.select(this).attr('data-video-id');
            await applyVideoSelection(videoId);
          });
        p.on('mouseenter', () => { setChartHighlightMany([s.videoId]); highlightVideoRowsByIds([s.videoId]); highlightMapForVideo(s.videoId); });
        p.on('mouseleave', () => { setChartHighlightMany(null); if (window.highlightSelectedVideoRow) window.highlightSelectedVideoRow(); if (!arcFilter) updateMapFlowHighlight(null); });
        p.on('click', async () => { await applyVideoSelection(s.videoId); });
      });
      
      // Ajouter un gestionnaire de clic sur le fond du graphique pour supprimer les filtres
      const svgChart = d3.select(chartDiv).select('svg');
      if (!svgChart.empty()) {
        svgChart.on('click', (ev) => {
          const target = ev.target;
          // Ignorer les clics sur les lignes (path.series-line) et les points (circle.series-point)
          if (target && target.tagName) {
            const tagName = target.tagName.toLowerCase();
            if ((tagName === 'path' && target.classList.contains('series-line')) ||
                (tagName === 'circle' && target.classList.contains('series-point'))) {
              return;
            }
          }
          // Supprimer les filtres dynamiques
          selectedVideoId = null; 
          selectedVideoData = null;
          arcFilter = null;
          chartFollowSelection = true; // Le fond réactive le suivi normal du graphe
          
          (async () => {
            // Recharger la liste selon les filtres courants (date/src/mode)
            const vids = await fetchVideos();
            videosCache = vids;
            if (window.renderVideoList) window.renderVideoList(vids);
            if (window.highlightSelectedVideoRow) window.highlightSelectedVideoRow();
            
            // Rétablir la map par défaut
            if (window.refreshMapOnly) await window.refreshMapOnly();
            
            // Rétablir le graphique par défaut
            const series = await fetchTimelinesForVideos(vids, 20);
            renderViewsChartMulti(series, null);
          })();
        });
      }
    }

    function setChartHighlightMany(videoIds){
      const ids = Array.isArray(videoIds) ? new Set(videoIds) : null;
      const svgC = d3.select(chartDiv).select('svg');
      if (svgC.empty()) return;
      
      // Mettre en surbrillance les lignes
      const lines = svgC.selectAll('path.series-line');
      if (!lines.empty()) {
        if (ids && ids.size){
          lines
            .attr('stroke-opacity', function(){ return ids.has(this.getAttribute('data-video-id')) ? 1 : 0.15; })
            .attr('stroke-width', function(){ return ids.has(this.getAttribute('data-video-id')) ? 3 : 2; });
        } else {
          lines.attr('stroke-opacity', 0.35).attr('stroke-width', 2);
        }
      }
      
      // Mettre en surbrillance les points
      const points = svgC.selectAll('circle.series-point');
      if (!points.empty()) {
        if (ids && ids.size){
          points
            .attr('fill-opacity', function(){ 
              const videoId = this.getAttribute('data-video-id');
              return (ids.has(videoId) || selectedVideoId === videoId) ? 0.7 : 0; 
            })
            .attr('r', function(){ return ids.has(this.getAttribute('data-video-id')) ? 2.5 : 2; });
        } else {
          points
            .attr('fill-opacity', function(){ 
              const videoId = this.getAttribute('data-video-id');
              return selectedVideoId === videoId ? 0.7 : 0; 
            })
            .attr('r', 2);
        }
      }
    }

    function highlightVideoRowsByIds(videoIds){
      const ids = Array.isArray(videoIds) ? new Set(videoIds) : null;
      const rows = Array.from(videoList.children).filter(el => el && el.dataset && el.dataset.videoId);
      rows.forEach(el => {
        if (ids && ids.size){
          el.style.background = ids.has(el.dataset.videoId) ? '#0b3a2a' : '';
        } else {
          el.style.background = '';
        }
      });
    }

    function highlightVideoRowsByPair(srcKey, dstKey){
      const rows = Array.from(videoList.children).filter(el => el && el.dataset && el.dataset.videoId);
      rows.forEach(el => {
        const a = el.dataset.srcKey || '';
        const b = el.dataset.dstKey || '';
        el.style.background = (srcKey && dstKey && a === srcKey && b === dstKey) ? '#0b3a2a' : '';
      });
    }

    const flowsByVideoCache = new Map();
    function updateMapFlowHighlight(pairs){
      const flowsSel = d3.select('#map').selectAll('path.flow');
      if (!pairs || !pairs.size){
        flowsSel.attr('stroke-opacity', null).attr('stroke-width', null);
        return;
      }
      flowsSel
        .attr('stroke-opacity', function(){
          const a = this.getAttribute('data-src-key');
          const b = this.getAttribute('data-dst-key');
          const key = `${a}->${b}`;
          return pairs.has(key) ? 1 : 0.08;
        })
        .attr('stroke-width', function(){
          const a = this.getAttribute('data-src-key');
          const b = this.getAttribute('data-dst-key');
          const key = `${a}->${b}`;
          return pairs.has(key) ? 2 : 1;
        });
    }

    async function highlightMapForVideo(videoId){
      if (arcFilter) return;
      if (!videoId){ updateMapFlowHighlight(null); return; }
      try{
        // Pour le survol, on peut utiliser le cache avec la date (comportement existant)
        const cacheKey = `${videoId}|${dateSlider.value}|${mode}`;
        let pairsSet = flowsByVideoCache.get(cacheKey);
        if (!pairsSet){
          const fl = await fetchFlowsByVideo(videoId, true); // Inclure la date pour le survol
          pairsSet = new Set((fl||[]).map(e => `${normalizeName(e.src)}->${normalizeName(e.dst)}`));
          flowsByVideoCache.set(cacheKey, pairsSet);
        }
        updateMapFlowHighlight(pairsSet);
      }catch{
        updateMapFlowHighlight(null);
      }
    }
    async function setChartHighlight(videoId){
      const selId = videoId || (selectedVideoId || null);
      const svgC = d3.select(chartDiv).select('svg');
      if (!svgC.empty()){
        const lines = svgC.selectAll('path.series-line');
        if (!lines.empty()){
          if (selId){
            lines
              .attr('stroke-opacity', function(){ return (this.getAttribute('data-video-id') === selId ? 1 : 0.15); })
              .attr('stroke-width', function(){ return (this.getAttribute('data-video-id') === selId ? 2 : 1); });
          } else {
            lines.attr('stroke-opacity', 0.35).attr('stroke-width', 1);
          }
        }
      }
      // surbrillance de TOUS les arcs (src,dst) pour cette vidéo (au jour+mode courant)
      if (!selId){
        updateMapFlowHighlight(null);
        return;
      }
      try{
        const cacheKey = `${selId}|${dateSlider.value}|${mode}`;
        let pairsSet = flowsByVideoCache.get(cacheKey);
        if (!pairsSet){
          const fl = await fetchFlowsByVideo(selId, true); // Inclure la date pour la surbrillance
          pairsSet = new Set((fl||[]).map(e => `${normalizeName(e.src)}->${normalizeName(e.dst)}`));
          flowsByVideoCache.set(cacheKey, pairsSet);
        }
        updateMapFlowHighlight(pairsSet);
      }catch{
        updateMapFlowHighlight(null);
      }
    }

    // Ancrage manuel supprimé - utilisation directe des noms de world-atlas

    function updateSelectedCountryHighlight(){
      const selected = (srcSelect && srcSelect.value) ? normalizeName(srcSelect.value) : null;
      const nodes = g.selectAll('path.country');
      nodes.classed('sel', false);
      if (selected) {
        nodes.filter(function(){
          const key = this.getAttribute('data-key') || '';
          return key === selected;
        }).classed('sel', true);
      }
    }

    function countryLonLat(geo, name){
      const key = normalizeName(name);
      
      // Coordonnées fixes pour les pays avec territoires d'outre-mer
      const fixedCoordinates = {
        'France': [2.3522, 46.2276],           // Centre de la France métropolitaine
        'United States': [-98.5795, 39.8283],  // Centre des États-Unis continentaux
        'United Kingdom': [-3.435973, 55.378051], // Centre du Royaume-Uni
        'Netherlands': [5.291266, 52.132633],  // Centre des Pays-Bas
        'Denmark': [9.501785, 56.26392],       // Centre du Danemark
        'Norway': [8.468946, 60.472024],       // Centre de la Norvège
        'Spain': [-3.74922, 40.463667],        // Centre de l'Espagne
        'Portugal': [-8.224454, 39.399872],    // Centre du Portugal
      };
      
      // Utiliser les coordonnées fixes si disponibles
      if (fixedCoordinates[key]) {
        return fixedCoordinates[key];
      }
      
      // Sinon utiliser le centroïde géométrique
      for(const f of geo.features){
        const nm = normalizeName(f.properties && f.properties.name);
        if(nm === key){
          const c = d3.geoCentroid(f);
          return c; // [lon, lat]
        }
      }
      
      return null;
    }

    function isVisibleLonLat(lonlat){
      if(!lonlat) return false;
      if (projectionMode === 'map' || projectionMode === 'blend') return true;
      const rot = d3.geoRotation(projection.rotate());
      const p = rot(lonlat);
      return d3.geoDistance([0,0], p) <= Math.PI/2 - 1e-6;
    }

    function countryCentroid(geo, name){
      const ll = countryLonLat(geo, name);
      if(!ll || !isVisibleLonLat(ll)) return null;
      if (projectionMode === 'blend' && typeof blendProjectFn === 'function') return blendProjectFn(ll);
      return projection(ll);
    }

    // Rotation animée du globe pour centrer un lon/lat au milieu
    function rotateToLonLat(lonlat, duration = 1000){
      if (projectionMode !== 'globe' || !lonlat) return;
      const r0 = projection.rotate();
      const target = [-(lonlat[0]||0), -(lonlat[1]||0), 0];
      const short = (a, b) => {
        const da = ((b - a + 540) % 360) - 180; // plus court chemin angulaire
        return (t) => a + da * t;
      };
      const yaw = short((r0[0]||0), target[0]);
      const pitch = short((r0[1]||0), target[1]);
      const roll = short((r0[2]||0), 0);
      d3.transition().duration(duration).ease(d3.easeCubicInOut)
        .tween('rotate', () => (t) => {
          projection.rotate([yaw(t), pitch(t), roll(t)]);
          render(worldGeo, lastFlows);
        });
    }

    function centerOnSelectedCountry(duration = 1000){
      if (projectionMode !== 'globe') return;
      if (!worldGeo || !srcSelect) return;
      const selected = srcSelect.value;
      if (!selected) return;
      const ll = countryLonLat(worldGeo, selected);
      if (ll) rotateToLonLat(ll, duration);
    }

    function render(geo, flows){

      g.selectAll('*').remove();
      // appliquer filtre d'arc si actif
      let flowsInput = flows;
      if (arcFilter && arcFilter.srcKey && arcFilter.dstKey){
        flowsInput = (flows||[]).filter(d => normalizeName(d.src) === arcFilter.srcKey && normalizeName(d.dst) === arcFilter.dstKey);
      }
      // Sphère (océan) et graticule (visible dans les deux modes)
      g.append('path')
        .datum({type:'Sphere'})
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937')
        .attr('stroke-width', .8)
        .attr('d', path);
      g.append('path')
        .datum(d3.geoGraticule10())
        .attr('fill', 'none')
        .attr('stroke', '#1f2937')
        .attr('stroke-opacity', 0.6)
        .attr('stroke-width', .5)
        .attr('d', path);
      g.selectAll('path.country').data(geo.features).join('path')
        .attr('class', 'country')
        .attr('d', path)
        .attr('data-key', d => normalizeName(d.properties && d.properties.name) || '')
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937').attr('stroke-width', .6);

      updateSelectedCountryHighlight();

      // const maxViews = d3.max(flows, d => d.views || 0) || 1;
      const maxCount = d3.max(flowsInput, d => d.count || 0) || 1;
      const stroke = d3.scaleSqrt().domain([1, maxCount]).range([2.0, 2.0]);
      const opacity = d3.scaleSqrt().domain([1, maxCount]).range([0.5, 1.0]);

      const arcs = flowsInput.map(d => {
        const srcLL = countryLonLat(geo, d.src);
        const dstLL = countryLonLat(geo, d.dst);
        if(!srcLL || !dstLL) {
          return null;
        }
        return { srcLL, dstLL, count: d.count, views: d.views, src: d.src, dst: d.dst };
      }).filter(Boolean);

      // Colorer en vert tous les pays destination présents dans les arcs
      const dstCountries = new Set(arcs.map(a => normalizeName(a.dst)).filter(Boolean));
      g.selectAll('path.country').classed('dst', function(){
        const key = this.getAttribute('data-key') || '';
        return dstCountries.has(key);
      });

      // Dessiner des courbes quadratiques simples
      const setHighlight = (key) => {
        g.selectAll('path.country').classed('hl', false);
        if (key) {
          const sel = g.select(`path.country[data-key="${key}"]`);
          sel.classed('hl', true);
        }
      };

      // Chemin visible des arcs (sans gestion d'événements)
      g.selectAll('path.flow').data(arcs).join('path')
        .attr('class', 'flow')
        .attr('data-src-key', d => normalizeName(d.src))
        .attr('data-dst-key', d => normalizeName(d.dst))
        .attr('fill', 'none')
        .attr('stroke', '#22c55e')
        .attr('stroke-opacity', d => opacity(d.count||0))
        .attr('stroke-width', d => stroke(d.count||0))
        .attr('d', d => {
          if (projectionMode === 'globe'){
            const interpolate = d3.geoInterpolate(d.srcLL, d.dstLL);
            const dist = d3.geoDistance(d.srcLL, d.dstLL);
            const steps = Math.max(8, Math.ceil(dist * 32));
            const coords = d3.range(steps + 1).map(t => interpolate(t/steps));
            const line = { type:'LineString', coordinates: coords };
            return path(line) || null;
          } else {
            const a = projection(d.srcLL);
            const b = projection(d.dstLL);
            const [x1,y1] = a, [x2,y2] = b;
            const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
            const dx = x2 - x1, dy = y2 - y1;
            const norm = Math.sqrt(dx*dx + dy*dy) || 1;
            const base = Math.min(80, norm * 0.3);
            const horiz = Math.abs(dx) / norm;
            const off = base * horiz;
            let px = -dy / norm, py = dx / norm; // perpendiculaire +90°
            if (py > 0) { px = -px; py = -py; } // garantir une composante y négative (vers le haut)
            const cx = mx + px * off;
            const cy = my + py * off;
            return `M${x1},${y1} Q${cx},${cy} ${x2},${y2}`;
          }
        })
        .style('pointer-events', 'none');

      // Calque d'interaction élargi pour faciliter le survol et le clic
      g.selectAll('path.flow-hit').data(arcs).join('path')
        .attr('class', 'flow-hit')
        .attr('fill', 'none')
        .attr('stroke', '#000')
        .attr('stroke-opacity', 0)
        .attr('stroke-width', d => (stroke(d.count||0) + 3))
        .attr('d', d => {
          if (projectionMode === 'globe'){
            const interpolate = d3.geoInterpolate(d.srcLL, d.dstLL);
            const dist = d3.geoDistance(d.srcLL, d.dstLL);
            const steps = Math.max(8, Math.ceil(dist * 32));
            const coords = d3.range(steps + 1).map(t => interpolate(t/steps));
            const line = { type:'LineString', coordinates: coords };
            return path(line) || null;
          } else {
            const a = projection(d.srcLL);
            const b = projection(d.dstLL);
            const [x1,y1] = a, [x2,y2] = b;
            const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
            const dx = x2 - x1, dy = y2 - y1;
            const norm = Math.sqrt(dx*dx + dy*dy) || 1;
            const base = Math.min(80, norm * 0.3);
            const horiz = Math.abs(dx) / norm;
            const off = base * horiz;
            let px = -dy / norm, py = dx / norm; // perpendiculaire +90°
            if (py > 0) { px = -px; py = -py; } // garantir une composante y négative (vers le haut)
            const cx = mx + px * off;
            const cy = my + py * off;
            return `M${x1},${y1} Q${cx},${cy} ${x2},${y2}`;
          }
        })
        .style('pointer-events', 'stroke')
        .on('mouseenter', (ev, d) => {
          const key = normalizeName(d.dst);
          setHighlight(key);
          arcHover = { srcKey: normalizeName(d.src), dstKey: normalizeName(d.dst), rawSrc: d.src, rawDst: d.dst };
          (async () => {
            try{
              const qs = new URLSearchParams();
              if (dates.length){ const idx = +dateSlider.value||0; const onDate = dates[Math.max(0, Math.min(idx, dates.length-1))]; if (onDate) qs.set('onDate', onDate); }
              qs.set('src', arcHover.rawSrc || '');
              qs.set('dst', arcHover.rawDst || '');
              if (mode) qs.set('mode', mode);
              const res = await fetch(`/api/videos/by_flow?${qs.toString()}`);
              const js = await res.json();
              const vids = (res.ok && js && Array.isArray(js.data)) ? js.data : [];
              const ids = vids.map(v => v.video_id);
              setChartHighlightMany(ids);
              if (ids.length){ highlightVideoRowsByIds(ids); } else { highlightVideoRowsByPair(arcHover.srcKey, arcHover.dstKey); }
            }catch{
              highlightVideoRowsByPair(arcHover.srcKey, arcHover.dstKey);
            }
          })();
        })
        .on('mousemove', (ev, d) => {
          tip.style.display = 'block';
          tip.style.left = (ev.clientX + 12) + 'px';
          tip.style.top = (ev.clientY + 12) + 'px';
          const v = d.views || 0;
          tip.textContent = `${d.src} → ${d.dst}: ${d.count} vidéos, ${d3.format(',')(v)} vues`;
        })
        .on('mouseleave', ()=>{
          tip.style.display = 'none';
          setHighlight(null);
          arcHover = null;
          setChartHighlightMany(null);
          highlightSelectedVideoRow();
        })
        .on('click', async (ev, d) => {
          arcFilter = { srcKey: normalizeName(d.src), dstKey: normalizeName(d.dst), rawSrc: d.src, rawDst: d.dst };
          render(worldGeo, lastFlows);
          try{
            const list = await fetchVideosByFlow(arcFilter.rawSrc, arcFilter.rawDst);
            videosCache = list;
            renderVideoList(list);
            const series = await fetchTimelinesForVideos(list, 10);
            renderViewsChartMulti(series, null);
            selectedVideoId = null; selectedVideoData = null; highlightSelectedVideoRow();
          }catch{}
        });

      // Cercles pour les flux où src == dst (comptage de vidéos distinctes au jour sélectionné)
      const selfFlows = flowsInput.filter(d => normalizeName(d.src) === normalizeName(d.dst));
      const maxSelf = d3.max(selfFlows, d => d.count || 0) || 1;
      const rSelf = d3.scaleSqrt().domain([1, maxSelf]).range([3, 16]);
      const points = selfFlows.map(d => {
        const ll = countryLonLat(geo, d.dst);
        if(!ll || !isVisibleLonLat(ll)) return null;
        const c = projection(ll);
        return { x:c[0], y:c[1], country:d.dst, count:d.count };
      }).filter(Boolean);

      g.selectAll('circle.self-flow').data(points).join('circle')
        .attr('class', 'self-flow')
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('r', d => rSelf(d.count||0))
        .attr('fill', '#22c55e')
        .attr('fill-opacity', 0.28)
        .attr('stroke', '#22c55e')
        .attr('stroke-width', 1)
        .on('mouseenter', (ev, d) => { setHighlight(normalizeName(d.country)); })
        .on('mousemove', (ev, d) => {
          tip.style.display = 'block';
          tip.style.left = (ev.clientX + 12) + 'px';
          tip.style.top = (ev.clientY + 12) + 'px';
          tip.textContent = `${d.country}: ${d.count} vidéo(s)`;
        })
        .on('mouseleave', ()=>{ tip.style.display = 'none'; setHighlight(null); });
    }

    // Rendu statique dans un calque dédié, pour crossfade (sans interactions)
    function renderSnapshot(geo, flows, mode, targetG){
      targetG.selectAll('*').remove();
      // config locale de projection
      const proj = (mode === 'globe')
        ? d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate(projection.rotate())
        : d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]);
      const pth = d3.geoPath(proj);

      const localIsVisible = (lonlat) => {
        if(!lonlat) return false;
        if (mode === 'map') return true;
        const rot = d3.geoRotation(proj.rotate());
        const pp = rot(lonlat);
        return d3.geoDistance([0,0], pp) <= Math.PI/2 - 1e-6;
      };

      const countryLL = (name) => {
        const key = normalizeName(name);
        for(const f of geo.features){
          const nm = normalizeName(f.properties && f.properties.name);
          if(nm === key){ return d3.geoCentroid(f); }
        }
        return null;
      };

      targetG.append('path')
        .datum({type:'Sphere'})
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937')
        .attr('stroke-width', .8)
        .attr('d', pth);
      targetG.append('path')
        .datum(d3.geoGraticule10())
        .attr('fill', 'none')
        .attr('stroke', '#1f2937')
        .attr('stroke-opacity', 0.6)
        .attr('stroke-width', .5)
        .attr('d', pth);
      targetG.selectAll('path.country').data(geo.features).join('path')
        .attr('class', 'country')
        .attr('d', pth)
        .attr('data-key', d => normalizeName(d.properties && d.properties.name) || '')
        .attr('fill', '#0b1220')
        .attr('stroke', '#1f2937').attr('stroke-width', .6);

      const maxCount = d3.max(flows, d => d.count || 0) || 1;
      const stroke = d3.scaleSqrt().domain([1, maxCount]).range([0.5, 0.5]);
      const opacity = d3.scaleSqrt().domain([1, maxCount]).range([0.25, 0.95]);

      const arcs = flows.map(d => {
        const srcLL = countryLL(d.src);
        const dstLL = countryLL(d.dst);
        if(!srcLL || !dstLL) return null;
        return { srcLL, dstLL, count: d.count, views: d.views, src: d.src, dst: d.dst };
      }).filter(Boolean);

      targetG.selectAll('path.flow').data(arcs).join('path')
        .attr('class', 'flow')
        .attr('fill', 'none')
        .attr('stroke', '#22c55e')
        .attr('stroke-opacity', d => opacity(d.count||0))
        .attr('stroke-width', d => stroke(d.count||0))
        .attr('d', d => {
          if (mode === 'globe'){
            const interpolate = d3.geoInterpolate(d.srcLL, d.dstLL);
            const dist = d3.geoDistance(d.srcLL, d.dstLL);
            const steps = Math.max(8, Math.ceil(dist * 32));
            const coords = d3.range(steps + 1).map(t => interpolate(t/steps));
            const line = { type:'LineString', coordinates: coords };
            return pth(line) || null;
          } else {
            const a = proj(d.srcLL);
            const b = proj(d.dstLL);
            const [x1,y1] = a, [x2,y2] = b;
            const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
            const dx = x2 - x1, dy = y2 - y1;
            const norm = Math.sqrt(dx*dx + dy*dy) || 1;
            const base = Math.min(80, norm * 0.3);
            const horiz = Math.abs(dx) / norm;
            const off = base * horiz;
            let px = -dy / norm, py = dx / norm;
            if (py > 0) { px = -px; py = -py; }
            const cx = mx + px * off;
            const cy = my + py * off;
            return `M${x1},${y1} Q${cx},${cy} ${x2},${y2}`;
          }
        });

      const selfFlows = flows.filter(d => normalizeName(d.src) === normalizeName(d.dst));
      const maxSelf = d3.max(selfFlows, d => d.count || 0) || 1;
      const rSelf = d3.scaleSqrt().domain([1, maxSelf]).range([3, 16]);
      const points = selfFlows.map(d => {
        const ll = countryLL(d.dst);
        if(!ll || !localIsVisible(ll)) return null;
        const c = proj(ll);
        return { x:c[0], y:c[1], country:d.dst, count:d.count };
      }).filter(Boolean);

      targetG.selectAll('circle.self-flow').data(points).join('circle')
        .attr('class', 'self-flow')
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('r', d => rSelf(d.count||0))
        .attr('fill', '#22c55e')
        .attr('fill-opacity', 0.28)
        .attr('stroke', '#22c55e')
        .attr('stroke-width', 1);
    }

    async function init(){
      const [geo, dateList] = await Promise.all([
        loadWorld(),
        fetch(`/api/meta/dates`).then(r=>r.json()).catch(()=>({dates:[]}))
      ]);
      worldGeo = geo;
      dates = (dateList && Array.isArray(dateList.dates)) ? dateList.dates : [];
      dateSlider.min = 0; dateSlider.max = Math.max(0, dates.length-1); dateSlider.value = 0;
      dateLabel.textContent = dates.length ? formatDateFrench(dates[0]) : '—';
      // Charger les pays source
      const channels = await fetch('/api/meta/channels').then(r=>r.json()).catch(()=>({countries:[]}));
      const countries = (channels && Array.isArray(channels.countries)) ? channels.countries : [];
      srcSelect.replaceChildren(...countries.map(c => {
        const opt = document.createElement('option');
        opt.value = c; opt.textContent = c; return opt;
      }));
      // Sélection par défaut: France
      const franceOpt = Array.from(srcSelect.options).find(o => (o.value||'').toLowerCase() === 'france');
      if(franceOpt){ srcSelect.value = franceOpt.value; }
      const [flows, vids] = await Promise.all([
        fetchFlows(),
        fetchVideos()
      ]);
      lastFlows = flows;
      render(geo, flows);
      centerOnSelectedCountry(800);
      videosCache = vids;
      renderVideoList(videosCache);
      // Rendre le graphe par défaut selon les filtres de démarrage
      try {
        const series = await fetchTimelinesForVideos(videosCache, 20);
        renderViewsChartMulti(series, null);
      } catch (e) {
        // silencieux
      }

      // Zoom & drag dépendants de la projection
      let dragEnabled = false;
      let isCtrlDown = false;
      function isDragActive(){ return !!(dragEnabled || isCtrlDown); }
      function setupInteractions(){
        // nettoyer anciens handlers
        svg.on('.zoom', null).on('.drag', null);
        if (projectionMode === 'globe'){
          // reset transform
          g.attr('transform', null);
          currentZoomK = Math.max(0.7, Math.min(12, currentZoomK));
          projection.scale(baseScaleGlobe * currentZoomK);
          zoomBehavior = d3.zoom()
            .scaleExtent([0.7, 12])
            .filter((event) => event.type === 'wheel')
            .on('zoom', (ev) => {
              currentZoomK = ev.transform.k;
              projection.scale(baseScaleGlobe * currentZoomK);
              render(geo, lastFlows);
            });
          svg.call(zoomBehavior).on('dblclick.zoom', null);

          dragBehavior = d3.drag()
            .filter((event) => isDragActive() && event.button === 0)
            .on('start', (ev) => {
              svg.style('cursor','grabbing');
              dragBehavior.__start = { x: ev.x, y: ev.y, r: projection.rotate() };
            })
            .on('drag', (ev) => {
              const s = dragBehavior.__start || { x: ev.x, y: ev.y, r: projection.rotate() };
              const dx = ev.x - s.x;
              const dy = ev.y - s.y;
              const sens = 0.25; // degrés par pixel
              const r0 = s.r || [0,0,0];
              const r = [ r0[0] + dx * sens, r0[1] - dy * sens, r0[2] || 0 ];
              projection.rotate(r);
              render(geo, lastFlows);
            })
            .on('end', () => { svg.style('cursor', isDragActive() ? 'grab' : 'default'); });
          svg.call(dragBehavior);
        } else {
          // mode carte: zoom/pan via transform, projection à l'échelle base
          projection = d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]);
          path = d3.geoPath(projection);
          zoomBehavior = d3.zoom()
            .scaleExtent([0.7, 12])
            .filter((event) => {
              if (event.type === 'wheel') return true;
              if (event.type === 'mousedown') return isDragActive() && event.button === 0;
              return false;
            })
            .on('start', () => { if (isDragActive()) svg.style('cursor','grabbing'); })
            .on('end',   () => { svg.style('cursor', isDragActive() ? 'grab' : 'default'); })
            .on('zoom', (ev) => { g.attr('transform', ev.transform); });
          svg.call(zoomBehavior).on('dblclick.zoom', null);
        }
      }

      // Bouton de réinitialisation de la vue
      const btnReset = document.getElementById('resetView');
      function resetView(){
        if (zoomBehavior) {
          svg.transition().duration(350).call(zoomBehavior.transform, d3.zoomIdentity);
        } else {
          g.attr('transform', null);
          currentZoomK = 1;
          projection = (projectionMode === 'globe')
            ? d3.geoOrthographic().scale(baseScaleGlobe).translate([width/2, height/2]).clipAngle(90)
            : d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]);
          path = d3.geoPath(projection);
          render(worldGeo, lastFlows);
        }
      }
      btnReset.addEventListener('click', resetView);
      // clic en dehors des arcs (sur fond) pour lever le filtre d'arc
      svg.on('click', (ev) => {
        const target = ev.target;
        if (target && target.tagName && target.tagName.toLowerCase() === 'path' && (target.classList.contains('flow') || target.classList.contains('country'))){
          // ignore: géré par handlers spécifiques
          return;
        }
        arcFilter = null;
        render(worldGeo, lastFlows);
        // rétablir graphe et liste par défaut
        (async () => {
          // Recharger la liste complète
          const vids = await fetchVideos();
          videosCache = vids;
          renderVideoList(videosCache);
          
          const series = await fetchTimelinesForVideos(videosCache, 10);
          renderViewsChartMulti(series, null);
          selectedVideoId = null; selectedVideoData = null;
          highlightSelectedVideoRow();
          highlightVideoRowsByIds(null);
          setChartHighlightMany(null);
        })();
      });

      // Bouton toggle drag
      const btnDrag = document.getElementById('toggleDrag');
      function updateDragUI(){
        btnDrag.classList.toggle('is-on', isDragActive());
        svg.style('cursor', isDragActive() ? 'grab' : 'default');
      }
      updateDragUI();
      btnDrag.addEventListener('click', () => {
        dragEnabled = !dragEnabled;
        updateDragUI();
      });

      // Activer le drag en maintenant Ctrl (sans changer l'état du bouton)
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Control' || e.ctrlKey) {
          if (!isCtrlDown) { isCtrlDown = true; updateDragUI(); }
        }
      });
      window.addEventListener('keyup', (e) => {
        if (e.key === 'Control' || (!e.ctrlKey && isCtrlDown)) {
          isCtrlDown = false; updateDragUI();
        }
      });

      function setProjectionMode(mode){
        const prevMode = projectionMode;
        const prevRotate = (typeof projection.rotate === 'function') ? projection.rotate() : [0,0,0];
        // Morphing réel des chemins entre prevMode -> mode
        morphProjection(prevMode, mode, prevRotate);
      }

      function morphProjection(prevMode, targetMode, prevRotate){
        // désactiver interactions pendant morph
        svg.on('.zoom', null).on('.drag', null);

        // Capturer le transform actuel avant de le modifier
        const currentTransform = d3.zoomTransform(svg.node());

        // Créer les projections source et cible avec gestion cohérente des échelles
        let proj0, proj1;
        
        const yawOnly = (Array.isArray(prevRotate) ? prevRotate[0] : 0) || 0;
        
        if (prevMode === 'globe') {
          // Pendant l'interpolation, neutraliser pitch/roll -> garder uniquement le yaw
          proj0 = d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate([yawOnly, 0, 0]);
        } else {
          // En mode carte, créer une projection qui reflète l'état visuel actuel (yaw uniquement)
          proj0 = d3.geoNaturalEarth1().scale(baseScaleMap * currentTransform.k).translate([
            width/2 + currentTransform.x, 
            height/2 + currentTransform.y
          ]).rotate([yawOnly, 0, 0]);
        }
          
        if (targetMode === 'globe') {
          // Pendant l'interpolation, neutraliser pitch/roll -> garder uniquement le yaw
          proj1 = d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate([yawOnly, 0, 0]);
        } else {
          proj1 = d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]).rotate([yawOnly, 0, 0]);
        }

        projectionMode = 'blend';
        const dur = 1200;

        // Supprimer le transform immédiatement pour éviter les conflits
        g.attr('transform', null);

        // Créer une transition unique et cohérente pour tous les éléments
        const transition = g.transition().duration(dur).ease(d3.easeQuadInOut);

        // Méthode standard D3 (ObservableHQ) : interpolation point par point entre projections
        const createPathTween = (geom) => {
          return (t) => {
            const interpolatedProj = d3.geoProjection((lambda, phi) => {
              const lonlat = [lambda * 180 / Math.PI, phi * -180 / Math.PI];
              const p0 = proj0(lonlat);
              const p1 = proj1(lonlat);
              if (!p0 || !p1) return null;
              return [
                p0[0] + t * (p1[0] - p0[0]), 
                p0[1] + t * (p1[1] - p0[1])
              ];
            }).scale(1).translate([width/2, height/2]);
            
            // Ne pas interpoler la rotation pour éviter un saut d'orientation
            
            return d3.geoPath(interpolatedProj)(geom);
          };
        };

        // Animer tous les pays
        transition.selectAll('path.country')
          .attrTween('d', function(d) { return createPathTween(d); });

        // Animer la sphère
        transition.selectAll('path')
          .filter((d) => d && d.type === 'Sphere')
          .attrTween('d', function(d) { return createPathTween(d); });

        // Animer le graticule
        const graticule = d3.geoGraticule10();
        transition.selectAll('path')
          .filter((d) => d && d.type === 'MultiLineString')
          .attrTween('d', function() { return createPathTween(graticule); });

        // Animer les flows (toujours en géodésiques pour la cohérence)
        transition.selectAll('path.flow')
          .attrTween('d', function(d) {
            return (t) => {
              const interpolate = d3.geoInterpolate(d.srcLL, d.dstLL);
              const dist = d3.geoDistance(d.srcLL, d.dstLL);
              const steps = Math.max(8, Math.ceil(dist * 20));
              const coords = d3.range(steps + 1).map(s => interpolate(s/steps));
              const line = { type:'LineString', coordinates: coords };
              return createPathTween(line)(t);
            };
          });

        // Animer les points self-flow
        transition.selectAll('circle.self-flow')
          .attrTween('cx', function(d){
            const ll = countryLonLat(worldGeo, d.country);
            if (!ll) return null;
            return (t) => {
              const p0 = proj0(ll);
              const p1 = proj1(ll);
              if (!p0 || !p1) return null;
              return p0[0] + t * (p1[0] - p0[0]);
            };
          })
          .attrTween('cy', function(d){
            const ll = countryLonLat(worldGeo, d.country);
            if (!ll) return null;
            return (t) => {
              const p0 = proj0(ll);
              const p1 = proj1(ll);
              if (!p0 || !p1) return null;
              return p0[1] + t * (p1[1] - p0[1]);
            };
          });

        // À la fin de la transition
        transition.on('end', () => {
          projectionMode = targetMode;
          if (targetMode === 'globe'){
            // Restaurer la rotation complète utilisateur (yaw/pitch/roll)
            projection = d3.geoOrthographic().scale(baseScaleGlobe * currentZoomK).translate([width/2, height/2]).clipAngle(90).rotate(prevRotate);
          } else {
            projection = d3.geoNaturalEarth1().scale(baseScaleMap).translate([width/2, height/2]).rotate([yawOnly, 0, 0]);
          }
          path = d3.geoPath(projection);
          setupInteractions();
          render(worldGeo, lastFlows);
          updateProjectionUI();
          updateSelectedCountryHighlight();
          if (targetMode === 'globe') { centerOnSelectedCountry(800); }
        });
      }

      function updateProjectionUI(){
        const isGlobe = (projectionMode === 'globe');
        projIcon.src = isGlobe ? '/public/img/globe_24p.svg' : '/public/img/map_24p.svg';
        projIcon.alt = isGlobe ? 'Globe' : 'Carte';
      }
      updateProjectionUI();
      toggleProjectionBtn.addEventListener('click', () => {
        const next = (projectionMode === 'globe') ? 'map' : 'globe';
        setProjectionMode(next);
      });

      // initialiser interactions selon mode courant
      setupInteractions();

      const refresh = async () => {
        const [fl, vids] = await Promise.all([
          selectedVideoId ? fetchFlowsByVideo(selectedVideoId, false) : fetchFlows(),
          (arcFilter && arcFilter.rawSrc && arcFilter.rawDst) ? fetchVideosByFlow(arcFilter.rawSrc, arcFilter.rawDst) : fetchVideos()
        ]);
        lastFlows = fl;
        render(geo, fl);
        videosCache = vids;
        renderVideoList(videosCache);
        if (selectedVideoId && chartFollowSelection !== false){
          const tl = await fetchVideoViewsTimeline(selectedVideoId);
          renderViewsChartMulti([{ videoId: selectedVideoId, data: tl }], selectedVideoId);
        } else {
          // Charger progressivement plus de timelines
          const series = await loadMoreTimelines(videosCache, 15);
          renderViewsChartMulti(series, null);
          // Précharger plus de timelines en arrière-plan
          preloadTimelines(videosCache, 300);
        }
      };

      async function refreshMapOnly(){
        const fl = await (selectedVideoId ? fetchFlowsByVideo(selectedVideoId, false) : fetchFlows());
        lastFlows = fl;
        render(geo, fl);
      }
      window.refreshMapOnly = refreshMapOnly;

      function highlightSelectedVideoRow(){
        const rows = Array.from(videoList.children);
        rows.forEach(row => {
          const isSel = selectedVideoId && row.dataset && row.dataset.videoId === selectedVideoId;
          row.style.background = isSel ? '#0b3a2a' : '';
        });
      }
      window.highlightSelectedVideoRow = highlightSelectedVideoRow;

      function renderVideoList(vids){
        const fmtNum = (n) => {
          const x = +n || 0;
          if (x >= 1000000) return (x/1000000).toFixed(x % 1000000 === 0 ? 0 : 1) + 'M';
          if (x >= 1000) return (x/1000).toFixed(x % 1000 === 0 ? 0 : 1) + 'k';
          return d3.format(',')(x);
        };

        // En-tête
        const header = document.createElement('div');
        header.style.display = 'grid';
        header.style.gridTemplateColumns = 'auto 1fr auto auto auto';
        header.style.gap = '8px';
        header.style.position = 'sticky';
        header.style.top = '0';
        header.style.background = '#0b1220';
        header.style.borderBottom = '1px solid var(--border)';
        header.style.padding = '4px 4px 6px 4px';
        const hRank = document.createElement('div'); hRank.textContent = '#'; hRank.style.color = '#9ca3af';
        const hTitle = document.createElement('div');
        const hViews = document.createElement('div');
        const hLikes = document.createElement('div');
        const hLink = document.createElement('div');
        const iLink = document.createElement('img'); iLink.src = '/public/img/media_link_24p.svg'; iLink.width = 18; iLink.height = 18; iLink.alt = 'Lien'; iLink.style.opacity = '0.8';
        hLink.appendChild(iLink);
        const iTitle = document.createElement('img'); iTitle.src = '/public/img/youtube_24p.svg'; iTitle.width = 18; iTitle.height = 18; iTitle.alt = 'YouTube'; iTitle.style.opacity = '0.9';
        const iViews = document.createElement('img'); iViews.src = '/public/img/views_24p.svg'; iViews.width = 18; iViews.height = 18; iViews.alt = 'Vues'; iViews.style.opacity = '0.8';
        const iLikes = document.createElement('img'); iLikes.src = '/public/img/thumbs_up_24p.svg'; iLikes.width = 18; iLikes.height = 18; iLikes.alt = 'Likes'; iLikes.style.opacity = '0.8';
        hTitle.appendChild(iTitle); hViews.appendChild(iViews); hLikes.appendChild(iLikes);
        header.appendChild(hRank); header.appendChild(hTitle); header.appendChild(hViews); header.appendChild(hLikes); header.appendChild(hLink);

        // Lignes
        const rows = vids.map((v, i) => {
          const row = document.createElement('div');
          row.style.display = 'grid';
          row.style.gridTemplateColumns = 'auto 1fr auto auto auto';
          row.style.gap = '8px';
          row.style.cursor = 'pointer';
          row.dataset.videoId = v.video_id;
          row.dataset.srcKey = normalizeName(v.src || '');
          row.dataset.dstKey = normalizeName(v.dst || '');
          const rank = document.createElement('div');
          rank.textContent = String(i + 1);
          rank.style.color = '#9ca3af';
          const title = document.createElement('div');
          title.textContent = v.video_title || v.video_id;
          const views = document.createElement('div');
          views.textContent = fmtNum(v.views||0);
          views.style.color = '#9ca3af';
          const likes = document.createElement('div');
          const linkCell = document.createElement('div');
          const a = document.createElement('a');
          a.href = `https://www.youtube.com/watch?v=${encodeURIComponent(v.video_id||'')}`;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          a.style.color = 'inherit';
          a.style.textDecoration = 'none';
          a.addEventListener('click', (ev) => { ev.stopPropagation(); });
          const aImg = document.createElement('img');
          aImg.src = '/public/img/play_arrow_24p.svg';
          aImg.width = 18;
          aImg.height = 18;
          aImg.alt = 'Lire sur YouTube';
          aImg.className = 'link-icon';
          a.appendChild(aImg);
          linkCell.appendChild(a);
          likes.textContent = fmtNum(v.likes||0);
          likes.style.color = '#9ca3af';
          row.appendChild(rank); row.appendChild(title); row.appendChild(views); row.appendChild(likes); row.appendChild(linkCell);
          row.addEventListener('mouseenter', () => { 
            setChartHighlight(v.video_id); 
            highlightMapForVideo(v.video_id);
          });
          row.addEventListener('mouseleave', () => { 
            setChartHighlight(null); 
            if (!arcFilter) updateMapFlowHighlight(null);
          });
          row.addEventListener('click', async () => {
            // Réinitialiser le filtre d'arc
            arcFilter = null;
            
            if (selectedVideoId === v.video_id){
              // Désélectionner => restaurer la liste complète
              selectedVideoId = null; selectedVideoData = null;
              const fullVideos = await fetchVideos();
              videosCache = fullVideos;
              renderVideoList(fullVideos);
              highlightSelectedVideoRow();
              if (window.refreshMapOnly) await window.refreshMapOnly();
              const series = await fetchTimelinesForVideos(fullVideos, 20);
              renderViewsChartMulti(series, null);
            } else {
              // Sélectionner => filtrer la liste pour cette vidéo uniquement
              selectedVideoId = v.video_id; selectedVideoData = v;
              const filteredVideos = [v]; // Afficher seulement cette vidéo
              renderVideoList(filteredVideos);
              highlightSelectedVideoRow();
              if (window.refreshMapOnly) await window.refreshMapOnly();
              const timeline = await fetchVideoViewsTimeline(selectedVideoId);
              renderViewsChartMulti([{ videoId: selectedVideoId, data: timeline }], selectedVideoId);
            }
          });
          return row;
        });
        videoList.replaceChildren(header, ...rows);
        highlightSelectedVideoRow();
      }
      window.renderVideoList = renderVideoList;
      // Debounce pour optimiser les mises à jour du slider
      let sliderTimeout = null;
      
      // Source fixe: yt_clean (pas d'écouteur de changement de table)
      dateSlider.addEventListener('input', async ()=>{
        // Mise à jour immédiate du label
        dateLabel.textContent = dates.length ? formatDateFrench(dates[+dateSlider.value]) : '—';
        
        // Annuler la mise à jour précédente si elle est en attente
        if (sliderTimeout) {
          clearTimeout(sliderTimeout);
        }
        
        // Programmer la mise à jour avec un délai minimal pour le debounce
        sliderTimeout = setTimeout(async () => {
          // NE PAS réinitialiser selectedVideoId si une vidéo est sélectionnée par clic
          // selectedVideoId = null; selectedVideoData = null;
          arcFilter = null; // Réinitialiser le filtre d'arc
          
          // Si une vidéo est sélectionnée, ne pas changer la liste/graphique
          if (selectedVideoId) {
            // Seulement mettre à jour la map avec les nouveaux flux
            const fl = await fetchFlows();
            lastFlows = fl;
            render(geo, fl);
            return; // Garder la vidéo sélectionnée et son graphique
          }
          
          // Mise à jour normale seulement si aucune vidéo n'est sélectionnée
          const [fl, vids] = await Promise.all([
            fetchFlows(),
            fetchVideos()
          ]);
          lastFlows = fl;
          render(geo, fl);
          videosCache = vids;
          if (window.renderVideoList) window.renderVideoList(videosCache);
          
          // Mise à jour du graphique avec les nouvelles données de la date sélectionnée
          // Recharger les timelines pour les vidéos de cette date spécifique
          const series = await loadMoreTimelines(videosCache, 15);
          renderViewsChartMulti(series, null);
        }, 50); // Débounce de 50ms pour une réactivité optimale
      });
      srcSelect.addEventListener('change', () => {
        selectedVideoId = null; selectedVideoData = null;
        arcFilter = null; // Réinitialiser le filtre d'arc
        updateSelectedCountryHighlight(); centerOnSelectedCountry(800); refresh();
      });
      toggleModeBtn.addEventListener('click', async () => {
        mode = (mode === 'off') ? 'on' : 'off';
        toggleModeBtn.textContent = mode.toUpperCase();
        selectedVideoId = null; selectedVideoData = null;
        arcFilter = null; // Réinitialiser le filtre d'arc
        await refresh();
      });
    }
    init();
  </script>
</body>
</html>


